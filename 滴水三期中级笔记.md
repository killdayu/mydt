# 滴水三期中级笔记

看了视频没怎么理清楚,所以写笔记理一下思路.可能以后玩会了就不写笔记了.

有2个原则:

1.只写我的理解,没理解到的不写.

2.先写通用的,后面要用到了再写特殊的.

------

环境配置:

 [双机调试_windbg.pdf](双机调试_windbg.pdf) 

## 1.保护模式

x86 CPU的3个模式:实模式,保护模式和虚拟8086模式.

建议先参考王爽的汇编语言,我3年前的笔记https://note.youdao.com/s/y3jcBKz.

------

由于历史遗留原因,8086所采用的20位地址总线,寻址地址达到了2的20次方,即1MB.但是由于采用的是16位架构,其他通用寄存器只能达到2的16次方寻址,即64KB.所以采用了段加偏移的方式来寻址,即段地址x16+偏移地址=物理地址.这一点在x86保护模式下也采用了,只不过32位的通用寄存器可以直接寻址所有地址,段寄存器的主要作用变为了权限控制,比如代码段可读可执行不可写,数据段可读可写不可执行.

在x86架构下的段寄存器有96位,但是只有16位可以直接改变.剩下的80位不能直接改变.

结构如下:

```c++
class SegMent
{
public:
	WORD Selector;		//段选择子

private:
	WORD Attributes;	//权限
	DWORD Base;			//基址
	DWORD Limit;		//段长度

};
```

由于不能直接改变段寄存器,所以我们只能间接的通过一张表来进行更改段寄存器,即全局描述符表(GPT,Global Descriptor Table),还有另外一张表,局部描述符表(LPT,Local Descriptor Table),Windows并没有用上.

```assembly
mov ax,es	//复制Selector到ax.
mov es,ax	//通过Selector查找GPT,然后加载GTPT对于的表到es.
//除了mov指令还有LES,LSS,LDS,LFS,LGS等指令可以修改段寄存器,还没有学到,先不讨论.
```

GPT表的位置,大小存储在gdtr(48位)寄存器中.

windbg:

```
kd> r gdtr
gdtr=8003f000
kd> r gdtl
gdtl=000003ff
kd> dq 8003f000 l10
ReadVirtual: 8003f000 not properly sign extended
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 00000000`00000000
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff
```

------

段选择子:

16位,指向了定义该段的段描述符. 

![image-20230326202402680](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230326202402680.png)

```
RPL:
请求特权级别.

TI:
TI=0 查GDT表.	//因为Windows只使用了GDT表,所以TI总为1.
TI=1 查LDT表.

Index:
表的索引,0开始.
```

EX:

| 0x23  | 0010 0011 |      |
| ----- | --------- | ---- |
| Index | TI        | RPL  |
| 00100 | 0         | 11   |
| 0x2B  | 0010 1011 |      |
| Index | TI        | RPL  |
| 00101 | 0         | 11   |
| 0x30  | 0011 0000 |      |
| Index | TI        | RPL  |
| 00110 | 0         | 00   |
| 0x3B  | 0011 1011 |      |
| Index | TI        | RPL  |
| 00110 | 0         | 11   |
| 0x53  | 0101 0011 |      |
| Index | TI        | RPL  |
| 01010 | 0         | 11   |

------

段描述符:

32位,定义了该段的属性.

![image-20230326203632589](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230326203632589.png)

```
P->G->S->TYPE.

P(段限制):
定义了该段描述符是否有效.
1	有效.
0	无效.

G(粒度):
定义了Segment Limit的单位
0	byte,最大为0x000FFFFF,1MB.
1	4kb,最大为0xFFFFFFFF,4GB.

S(描述符类型):
0	system.
1	code或者data.

TYPE(段类型):
和S有关,此处略.
```

TYPE:

S = 1:

![image-20230326210024318](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230326210024318.png)

```
Data:
    A(accessed):
    访问位.
    W(Write):
    可写位.
    E(expand-down):
    拓展位.
```

向上拓展和向下拓展,红色为段空间,即向上拓展和向下拓展互为补集,全集的大小和D/B有关(16/32位寻址方式).

![image-20230326210514299](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230326210514299.png)

```
Code:
    A(accessed):
    访问位.
    R(Read):
    可读位.
    C(conforming):
    一致位,此处略.
```

S = 0:

![image-20230326210109852](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230326210109852.png)

EX:

```
kd> dq 8003f000 l10
ReadVirtual: 8003f000 not properly sign extended
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 00000000`00000000
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff

段选择子为0x23,00100 0 11,索引为4,00cff300`0000ffff.P位所在的f大于等于8,即P位为1,该段描述符有效,G位为1,S位为1,是code/data段,TYPE为3,Data段,权限为:Read/Write,accessed.
Base:00000000
Atrribute:cff3
Limit:0xffffffff

段选择子为0x2B,00101 01 1,索引为5,80008b04`200020ab.P位所在的8等于大于8,即P位为1,该段描述符有效,G位为0,S位为0,是system段,TYPE为11,权限为:32-Bit TSS(Busy).
Base:80042000
Atrribute:008b
Limit:0x0ffff000

段选择子为0x30,00110 0 00,索引为6,ffc093df`f0000001.P位所在的9等于大于8,即P位为1,该段描述符有效,G位为1,S位为1,是code/data段,TYPE为3,Data段,权限为:Read/Write,accessed.
Base:ffdff000
Atrribute:c093
Limit:0x00001fff

段选择子为0x3B,00111 0 11,索引为7,0040f300`00000fff.P位所在的f等于大于8,即P位为1,该段描述符有效,G位为0,S位为1,是code/data段,TYPE为3,Data段,权限为:Read/Write,accessed.
Base:00000000
Atrribute:40f3
Limit:0x00000fff

段选择子为0x53,01010 0 11,索引为10,80008955`27000068.P位所在的8等于大于8,即P位为1,该段描述符有效,G位为0,S位为0,是system段,TYPE为9,权限为:Available.
Base:80552700
Atrribute:0089
Limit:0x00000068
```

------

段权限检查:

GPL(Global Privilege Level):
全局特权级别,GDT表里面的段描述符

CPL(Current Privilege Level):
当前特权级别,当前CS段选择子后2位

RPL(Requested Privilege Level):
请求特权级别,要使用的段选择子后2位

```
数据段的权限检查：
CPL <= DPL 并且 RPL <= DPL (数值上的比较)

kd> dq 8003f000
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 7f40f3fd`f0000fff
8003f040  0000f200`0400ffff 00000000`00000000
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff

mov ax,0xB
mov es,eax	//1011->1 0 11->00cf9b00`0000ffff,dpl为0,所以执行后权限检查不通过,就会触发异常,跳转到ntdll
```

------

代码跨段:

本质就是修改CS段寄存器,和EIP一样,涉及到代码的寄存器都无法通过指令直接改变.修改EIP可以使用jcc,call,ret等指令,CS段寄存器也一样,只不过是长跳转,jcc far,call far,retf等.

```
jmp 0x20:0x004183d7	//段选择子:偏移,即EIP(base通常为0).

1.段选择子拆分:
0x20->00100 0 00
2.GDT表拿到段描述符:
四种情况可以跳转:代码段,调用门,TSS任务段,任务门.这里只实验代码段.
3.权限检查:
非一致代码段:CPL == DPL && RPL <= DPL
一致代码段:CPL >= DPL
4.加载段描述符:
将段描述符加载到CS
5.代码执行:
EIP:CS.base + offset.
然后执行CS:EIP

一致位(conforming):
S为1,TYPE大于等于12,就为一致性代码段.

总结：
对于一致代码段:也就是共享的段
	特权级高的程序不允许访问特权级低的数据:核心态不允许访问用户态的数据
	特权级低的程序可以访问到特权级高的数据,但特权级不会改变:用户态还是用户态

对于普通代码段:也就是非一致代码段
	只允许同级访问
	绝对禁止不同级别的访问:核心态不是用户态,用户态也不是核心态.

直接对代码段进行JMP或者CALL的操作,无论目标是一致代码段还是非一致代码段,CPL都不会发生改变.如果要提升CPL的权限,只能通过调用门.
```

```
kd> dq 8003f000
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 7f40f3fd`f0000fff
8003f040  0000f200`0400ffff 00000000`00000000
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff
```

00cffb00`0000ffff为非一致代码段,CPL(3) == DPL(3) && RPL <= DPL(3),构造段选择子,0x11011. 

```
jmp far 001b:004183fd	//OK
jmp far 0008:004183fd	//ERROR
```

8003f048:00cfff00`0000ffff为一致代码段,CPL(3) >= DPL(0)

```
kd> eq 8003f048 00cfff00`0000ffff
WriteVirtual: 8003f048 not properly sign extended
kd> dq 8003f000
ReadVirtual: 8003f000 not properly sign extended
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 00cfff00`0000ffff
8003f050  00000000`0000ffff 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff

jmp far 004b:004183fd	//OK
```

![image-20230327213902570](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230327213902570.png)

------

长调用堆栈图:

指令格式：CALL  CS:EIP(EIP是废弃的)

1.跨段不提权:CPL权限并不发生改变,所以堆栈不变.

![image-20230329092803222](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230329092803222.png)

2.跨段并提权:CPL会改变,所以堆栈的特权级别也改变.

![image-20230329093028707](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230329093028707.png)

------

EX:

```c
#include "stdafx.h"
#include <windows.h>

void __declspec(naked) GetRegister()
{
	__asm
	{
		int 3

		retf
	}
}



int main(int argc, char* argv[])
{
	char buff[6];
	*(DWORD*)&buff[0] = 0x12345678;
	*(WORD*)&buff[4] = 0x48;
	__asm
	{
		call fword ptr[buff]
	}

	getchar();

	return 0;
}
```

![image-20230329103049437](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230329103049437.png)

![image-20230329103219542](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230329103219542.png)

```c
#include "stdafx.h"
#include <windows.h>

BYTE GDT[6] = {0};
DWORD dwH2GValue;

void __declspec(naked) GetRegister()
{
	__asm
	{
		pushad
		pushfd

		mov eax,0x8003f000
		mov ebx,[eax]
		mov dwH2GValue,ebx
		sgdt GDT

		popfd
		popad
		retf
	}
}

void PrintRegister()
{
	DWORD GDT_ADDR = *(PDWORD)(&GDT[2]);
	WORD GDT_LIMIT = *(PWORD)(&GDT[0]);

	printf("%x %x %x\n", dwH2GValue, GDT_ADDR, GDT_LIMIT);
}

int main(int argc, char* argv[])
{
	char buff[6];
	*(DWORD*)&buff[0] = 0x12345678;
	*(WORD*)&buff[4] = 0x48;
	__asm
	{
		call fword ptr[buff]
	}

	PrintRegister();
	getchar();

	return 0;
}
```

![image-20230329105047862](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230329105047862-1680058248632-1.png)

------

```c
#include "stdafx.h"
#include <windows.h>

DWORD x, y, z;

void __declspec(naked) GetRegister()
{
	__asm
	{
		pushad
		pushfd
		
		mov eax,[esp+0x24+0x8+0x8]	//0x24是pushad,pushfd进去的9个寄存器,0x8是EIP,CS.push进去的参数在中间,然后末尾是ESP,CS.
		mov dword ptr ds:[x],eax
		mov eax,[esp+0x24+0x8+0x4]
		mov dword ptr ds:[y],eax
		mov eax,[esp+0x24+0x8+0x0]
		mov dword ptr ds:[z],eax
		mov eax,0x0040db20
		mov dword ptr [esp+0x24],eax

		popfd
		popad
		retf 0xC
	}
}

void PrintRegister()
{
	printf("%x %x %x\n", x, y, z);
}

void print666()
{
	while(true)
	{
		Sleep(1000);
		printf("666");
	}
}

int main(int argc, char* argv[])
{
	char buff[6];
	*(DWORD*)&buff[0] = 0x12345678;
	*(WORD*)&buff[4] = 0x48;
	__asm
	{
		push 1
		push 2
		push 3
		call fword ptr[buff]
	}

	PrintRegister();
	getchar();

	return 0;
}
```

------

中断门:

```c
#include "stdafx.h"
#include <windows.h>

DWORD dwH2GValue;

void __declspec(naked) GetRegister()
{
	__asm
	{	
        int 3
		/*
		只能
        mov eax,0x12345678
        mov eax,[eax]
        不能直接
        mov eax,[0x12345678]  
		*/
		mov eax,0x8003f400		//mov eax,[0x8003f400]
		mov ebx,[eax]
		mov dwH2GValue,ebx

		iretd
	}
}

void PrintRegister()
{
	printf("%x \n", dwH2GValue);
}

int main(int argc, char* argv[])
{
	__asm
	{
		INT 0x20
	}

	PrintRegister();

	return 0;
}
```

![image-20230402150310592](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230402150310592.png)

 EIP->CS->EFL->ESP->SS

![img](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/1197364-20200712230227891-1208895313.png)

中断门和调用门的除了流程之外的区别是:

1.中断门的权限校验在IDT中,调用门在GDT.

2.中断门调用时堆栈会多保存EFL寄存器.

3.中断门不能传递参数.

------

陷阱门:

![image-20230402150745462](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230402150745462.png)

![img](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/1197364-20200719110036207-1537688390.png)

陷阱门与中断门唯一的不同就是ELF中的IF位,中断门执行后IF设置为0,陷阱门执行后IF不变.

------

任务状态段 TSS(Task State Segment):

同时改变很多寄存器的值.

![image-20230402192807473](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230402192807473.png)

TR寄存器:

LTR(Load TR):

用LTR指令去装载的话 仅仅是改变TR寄存器的值(96位) 并没有真正改变TSS 

LTR指令只能在系统层使用

加载后TSS段描述符会状态位会发生改变

STR(Save TR):

如果用STR去读的话，只读了TR的16位 也就是选择子

```c
// TSS.cpp : Defines the entry point for the console application.
//
 
#include <stdlib.h>
#include <stdio.h>
 
 
void __declspec(naked) EipFunction()
{
	__asm
	{
		int 3;   //便于内核调试器断下
		push ebp;
		mov ebp, esp;
 
		
	}
}
 
 
int main(int argc, char* argv[])
{
	char espBuffer[0x30] = { 0 }; //开辟空间构建TSS内存的栈顶
	printf("Please Input Cr3 Value \r\n");
	unsigned int Cr3Value = 0;
	scanf("%d", &Cr3Value);
	//构建TSS的内存
	unsigned int TssMemory[0x64] = {
	0x00000000,// Previous TaskLink 操作系统会给写入
	0x00000000,// esp 0
	0x00000000,// ss  0
	0x00000000,// esp 1
	0x00000000,// ss  1
	0x00000000,// esp 2
	0x00000000,// ss  2
	(unsigned int)Cr3Value,
	(unsigned int)EipFunction,// EIP              执行你函数的地址.EIP指向.这样才可以执行你的函数
	0x00000000,// eflags 
	0x12345678,// eax
	0x87654321,// ecx
	0x11223344,// edx
	0x44332211,// ebx              寄存器随便给.便于调试的时候更直观的看到
	(unsigned int)espBuffer,	// esp              栈顶的值.需要我们指定
	0x00000000,// ebp              栈底的值
	0x00000000,// esi
	0x00000000,// edi
	0x00000023,// es				段寄存器我们也要给 如果切换到内核则按照内核中的给.
	0x00000008,// cs				0环的代码段选择子. 如果想要切换rign3就给ring3的. 可以windbg调试
	0x00000010,// ss                同cs一样.ss与cs必须在同一代码段下
	0x00000023,// ds
	0x00000030,// fs
	0x00000000,// gs
	0x00000000,// LDT
	0x20ac0000,// Io              这个根据Windbg调试得出来.看一下填写即可.
	};
 
	printf("TSS内存的地址为 : %p \r\n", TssMemory);     //输出一下TSS内存的地址. 便于构造段描述符.
	fflush(stdin);
    getchar();
	char FarAddress[6] = { 0 };//构造我们的远call 指令.同调用门一样
	//call far 段选择子:eip 
	*(unsigned int*)&FarAddress[0] = 0x00000000; //EIP在远call的时候不用.随便给.
	*(unsigned short*)&FarAddress[4] = 0x48;    //构造的TSS段在GDT表中的段选择子.
	__asm
	{
		call fword ptr[FarAddress];
	}
	printf("over _ \r\n");
	system("pause");
	return 0;
}
```

需要TSS表在连续的页上,有点靠运气,我蓝屏好几次都没成功.

------

页:

10-10-12

ntoskrnl.exe:MmIsAddressValid

```c
BOOLEAN __stdcall MmIsAddressValid(PVOID VirtualAddress)
{
  int v1; // eax
  _DWORD *v2; // eax
  BOOLEAN result; // al

  v1 = *(_DWORD *)((((unsigned int)VirtualAddress >> 20) & 0xFFC) - 1070596096);
  result = 0;
  if ( (v1 & 1) != 0 )
  {
    if ( (v1 & 0x80u) != 0 )
      return 1;
    v2 = (_DWORD *)((((unsigned int)VirtualAddress >> 10) & 0x3FFFFC) - 0x40000000);
    if ( (*v2 & 1) != 0
      && ((*v2 & 0x80u) == 0 || (*(_DWORD *)((((unsigned int)VirtualAddress >> 10) & 0xFFC) - 1070596096) & 0x81) != 0x81) )
    {
      return 1;
    }
  }
  return result;
}
```

```assembly
.text:0040AEC6 8B FF                         mov     edi, edi
.text:0040AEC8 55                            push    ebp
.text:0040AEC9 8B EC                         mov     ebp, esp
.text:0040AECB 8B 4D 08                      mov     ecx, [ebp+VirtualAddress]	#设线性地址为0x00428C50
.text:0040AECE 8B C1                         mov     eax, ecx		#eax=0x00428C50
.text:0040AED0 C1 E8 14                      shr     eax, 14h		#右移0x14,20位,为什么不是右移10+12位呢,后面有个巧妙的办法,eax=0000 0000 0100
.text:0040AED3 BA FC 0F 00 00                mov     edx, 0FFCh		#edx=0000 1111 1111 1100
.text:0040AED8 23 C2                         and     eax, edx		#这里很巧妙,直接将eax后2位清空,然后现在eax的值就是第一个10位(DPI)*4后的结果,即PDE
.text:0040AEDA 2D 00 00 D0 3F                sub     eax, 3FD00000h	#PDE-3FD00000h=PDE+C0300000,现在将eax里面的线性地址就是PDE对应的物理地址
.text:0040AEDF 8B 00                         mov     eax, [eax]		#取PDE的值
.text:0040AEE1 A8 01                         test    al, 1			#逻辑与,检查P位是否为1,有效位
.text:0040AEE3 0F 84 BC 2E 01 00             jz      loc_41DDA5		
.text:0040AEE3
.text:0040AEE9 84 C0                         test    al, al			#判断al是否为0?但之前不已经P位为1了吗,看别人注释是为了判断PS位,大页,这里不太懂
.text:0040AEEB 78 24                         js      short loc_40AF11	
.text:0040AEEB
.text:0040AEED C1 E9 0A                      shr     ecx, 0Ah		#ecx=0x00428C50,右移0xA,10位,ecx=10A3(0000 0000 01,00 0010 1000 11)
.text:0040AEF0 81 E1 FC FF 3F 00             and     ecx, 3FFFFCh	#ecx=10A0,擦,这里为什么是3FFFFC,而不是FFFFFC?
.text:0040AEF6 81 E9 00 00 00 40             sub     ecx, 40000000h	#...没想通,反正现在ecx里面的线性地址就是PTE对应的物理地址
.text:0040AEFC 8B C1                         mov     eax, ecx	
.text:0040AEFE 8B 08                         mov     ecx, [eax]		#取出PTE
.text:0040AF00 F6 C1 01                      test    cl, 1			#判断PTE,P位
.text:0040AF03 0F 84 9C 2E 01 00             jz      loc_41DDA5
.text:0040AF03
.text:0040AF09 84 C9                         test    cl, cl			#判断PAT位
.text:0040AF0B 0F 88 3F 42 04 00             js      loc_44F150
.text:0040AF0B
.text:0040AF11
.text:0040AF11                               loc_40AF11:                             ; CODE XREF: MmIsAddressValid(x)+25↑j
.text:0040AF11                                                                       ; MmIsAddressValid(x)+44298↓j
.text:0040AF11 B0 01                         mov     al, 1
.text:0040AF11
.text:0040AF13
.text:0040AF13                               loc_40AF13:                             ; CODE XREF: MmIsAddressValid(x)+12EE1↓j
.text:0040AF13 5D                            pop     ebp
.text:0040AF14 C2 04 00                      retn    4
```

------

2-9-9-12

ntkrnlpa.exe:MmIsAddressValid

```c
BOOLEAN __stdcall MmIsAddressValid(PVOID VirtualAddress)
{
  int v1; // edx
  _DWORD *v2; // ecx
  BOOLEAN result; // al

  v1 = *(_DWORD *)((((unsigned int)VirtualAddress >> 18) & 0x3FF8) - 1067450368);
  result = 0;
  if ( (v1 & 1) != 0 )
  {
    if ( (v1 & 0x80) != 0 )
      return 1;
    v2 = (_DWORD *)((((unsigned int)VirtualAddress >> 9) & 0x7FFFF8) - 0x40000000);
    if ( (*v2 & 1) != 0
      && ((*v2 & 0x80) == 0 || (*(_DWORD *)((((unsigned int)VirtualAddress >> 9) & 0x3FF8) - 1067450368) & 0x81) != 129) )
    {
      return 1;
    }
  }
  return result;
}
```

chatgpt:

```c
// 判断虚拟地址是否有效
// 返回值为 BOOLEAN 类型，表示是否有效
BOOLEAN IsVirtualAddressValid(PVOID VirtualAddress)
{
  // 计算目标地址所在的页表项
  int PageDirectoryEntry = *(_DWORD *)((((unsigned int)VirtualAddress >> 18) & 0x3FF8) - 0x3FA00000);
  BOOLEAN result = 0;

  // 如果页表项标志为存在
  if ( (PageDirectoryEntry & 1) != 0 )
  {
    // 如果页表项标志为用户态访问或全局页
    if ( (PageDirectoryEntry & 0x80) != 0 )
      return 1;

    // 计算目标地址所在的页表项
    _DWORD *PageTableEntry = (_DWORD *)((((unsigned int)VirtualAddress >> 9) & 0x7FFFF8) - 0x40000000);
    
    // 如果页表项标志为存在
    if ( (*PageTableEntry & 1) != 0
      // 如果页表项标志为用户态访问或全局页，或者页表项标志为内核态访问，但 CR3 控制寄存器的高位为 1
      && ((*PageTableEntry & 0x80) == 0 || (*(_DWORD *)((((unsigned int)VirtualAddress >> 9) & 0x3FF8) - 0x3FA00000) & 0x81) != 0x81) )
    {
      // 返回地址有效
      return 1;
    }
  }

  // 返回地址无效
  return result;
}
```

------

```c
#include "stdafx.h"
#include <windows.h>

DWORD TempFnAddress;

void __declspec(naked) Proc()
{
	__asm
	{
		//1.给0地址挂物理页	0x01234867(G=0)	0x01234967(G=1)
		mov dword ptr ds:[0xC0000000],0x01234867
		//2.给0地址赋值
		mov dword ptr ds:[0],0x66666666

		INVLPG dword ptr ds:[0]	//删除0地址的tls
		mov eax,cr3
		mov cr3,eax	//刷新cr3

		//3.改变物理页
		mov dword ptr ds:[0xC0000000],0x02345679

		//4.再次读取线性地址
		mov eax,dword ptr ds:[0]
		mov TempFnAddress,eax

		retf
	}
}

int main(int argc, char* argv[])
{
	char buff[6] = {0};
	
	*(DWORD*)&buff[4] = 0x48;	//01001 0 00 -> 9

	__asm
	{
		call fword ptr[buff]
	}
	
	printf("%x\n", TempFnAddress);

	return 0;
}


```

```
kd> dq 8003f000
ReadVirtual: 8003f000 not properly sign extended
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 00000000`00000000
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff

eq 8003f048 0040EC00`0008D865
0x0012fec0

1111 0010 EC

//在8003f048 位置构造一个3环进0环的调用门,偏移先用0代替


 EAX = 00000000 EBX = 7FFD8000
 ECX = 00000000 EDX = 00380E28
 ESI = 00000000 EDI = 0012FF80
 EIP = 0040104A ESP = 0012FEC0
 EBP = 0012FF80 EFL = 00000246

```

------

```c
#include "stdafx.h"
#include <windows.h>

DWORD dwAddrTmp;
DWORD PDI;
DWORD PTI;
DWORD Offset;

bool ReadMemory(OUT BYTE* buffer,IN DWORD dwAddr,IN DWORD dwLeght)
{
	dwAddrTmp = dwAddr;
	PDI = dwAddrTmp >> 22;
	dwAddrTmp = dwAddr;
	PTI = (dwAddrTmp >> 12) & 0x3FF;
	dwAddrTmp = dwAddr;
	Offset = dwAddrTmp & 0xFFF;
	
	printf("PDI:%x,PTI:%x,Offset:%x.\n", PDI, PTI, Offset);
	
	//DWORD PTE = 0xC0000000 + PDI * 0x4000 + PTI;

	//printf("PTE:%x", *(DWORD*)PTE);


	return false;
}

int main(int argc, char* argv[])
{
	BYTE buffTmp[6] = {0};
	BYTE buffer[100] = {0};
	DWORD dwAddr = 0x00401234;
	DWORD dwLeght = 4;
	
	//printf("%s", (BYTE*)dwAddr);
	
	
	*(DWORD*)&buffTmp[4] = 0x48;	//01001 0 00 -> 9
	__asm
	{
		push dwLeght
		push dwAddr
		push buffer

		call fword ptr[buffTmp]
	}

	/*
	bool x = ReadMemory(buffer,dwAddr,dwLeght);
	if(x = true)
	{
		printf("%x:%s.\n", dwAddr, buffer);
	}else
	{
		printf("ReadMemory error!\n");
	}
	*/

	return 0;
}
```

```c
#include "stdafx.h"
#include <windows.h>

int main(int argc, char* argv[])
{
	BYTE buffTmp[6] = {0};
	
	*(DWORD*)&buffTmp[4] = 0x48;	//01001 0 00 -> 9

	__asm
	{
		int 3	//eq 8003f048 0040EC00`0008D865
		call fword ptr[buffTmp]	//下一条指令的地址:0040D865
		mov esp,[esp+0x8]	//由于使用调用门之后会根据TSS重新分配ESP，所以需要回到之前的esp，现在cs，ss都是ring0.
	}
	
	DWORD dwAddr = 0x00400000;
	DWORD dwLeght = 4;

	DWORD dwAddrTmp = dwAddr;
	DWORD PDI = dwAddrTmp >> 22;
	dwAddrTmp = dwAddr;
	DWORD PTI = (dwAddrTmp >> 12) & 0x3FF;
	dwAddrTmp = dwAddr;
	DWORD Offset = dwAddrTmp & 0xFFF;
	
	printf("PDI:%x,PTI:%x,Offset:%x.\n", PDI, PTI, Offset);
	printf("%x\n", *(DWORD*)0xC0004000);

	return 0;
}

```

## 2.驱动

```c
#include <ntifs.h> //这个头文件内包含了大量驱动相关的头文件，一次性包含，省时省力。
```

```c
#include "ntddk.h"
 
void UnloadDriver(PDRIVER_OBJECT driver);
 
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) {
	DbgBreakPoint();
    DbgPrint("-------%wZ--------",RegistryPath);
    DbgPrint("驱动加载了。\r\n");    //驱动的打印函数，相当于3环的printf
	DbgPrint("DriverObject:%p。\r\n", DriverObject);
    DriverObject->DriverUnload = UnloadDriver;    //为驱动指定卸载函数
    return STATUS_SUCCESS;
}
//驱动卸载函数
void UnloadDriver(PDRIVER_OBJECT driver) {
    DbgPrint("驱动停止了。\r\n");
}
```

```
kd> dt _DRIVER_OBJECT 0x8A22ED18
nt!_DRIVER_OBJECT
   +0x000 Type             : 0n4
   +0x002 Size             : 0n168
   +0x004 DeviceObject     : (null) 
   +0x008 Flags            : 0x12
   +0x00c DriverStart      : 0xba428000 Void
   +0x010 DriverSize       : 0x6000
   +0x014 DriverSection    : 0x8a13a9d8 Void
   +0x018 DriverExtension  : 0x8a22edc0 _DRIVER_EXTENSION
   +0x01c DriverName       : _UNICODE_STRING "\Driver\驱动"
   +0x024 HardwareDatabase : 0x8067f260 _UNICODE_STRING "\REGISTRY\MACHINE\HARDWARE\DESCRIPTION\SYSTEM"
   +0x028 FastIoDispatch   : (null) 
   +0x02c DriverInit       : 0xba429000     long  _empty_!DriverEntry+0
   +0x030 DriverStartIo    : (null) 
   +0x034 DriverUnload     : 0xba429050     void  _empty_!UnloadDriver+0
   +0x038 MajorFunction    : [28] 0x804f55ce     long  nt!IopInvalidDeviceRequest+0
kd> dd 0xba428000
ReadVirtual: ba428000 not properly sign extended
ba428000  00905a4d 00000003 00000004 0000ffff
ba428010  000000b8 00000000 00000040 00000000
ba428020  00000000 00000000 00000000 00000000
ba428030  00000000 00000000 00000000 000000c0
ba428040  0eba1f0e cd09b400 4c01b821 685421cd
ba428050  70207369 72676f72 63206d61 6f6e6e61
ba428060  65622074 6e757220 206e6920 20534f44
ba428070  65646f6d 0a0d0d2e 00000024 00000000
kd> dt _DRIVER_EXTENSION 0x8a22edc0
nt!_DRIVER_EXTENSION
   +0x000 DriverObject     : 0x8a22ed18 _DRIVER_OBJECT
   +0x004 AddDevice        : (null) 
   +0x008 Count            : 0
   +0x00c ServiceKeyName   : _UNICODE_STRING "驱动"
   +0x014 ClientDriverExtension : (null) 
   +0x018 FsFilterCallbacks : (null) 
```

```
dt _LDR_DATA_TABLE_ENTRY 0x8a13a9d8
```

打印所有模块

```c
#include <ntifs.h>
 
void UnloadDriver(PDRIVER_OBJECT driver);

typedef struct _LDR_DATA_TABLE_ENTRY {
    LIST_ENTRY InLoadOrderLinks;
    ULONG __Undefined1;
    ULONG __Undefined2;
    ULONG __Undefined3;
    ULONG NonPagedDebugInfo;
    ULONG DllBase;
    ULONG EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT __Undefined5;
    ULONG  __Undefined6;
    ULONG  CheckSum;
    ULONG  TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) {
    PLDR_DATA_TABLE_ENTRY selfNode = (PLDR_DATA_TABLE_ENTRY)DriverObject->DriverSection;
    PLDR_DATA_TABLE_ENTRY preNode = selfNode;
    UINT32 index = 1;
    do {
        DbgPrint("[db] %d  driver name = %wZ \r\n", index++,&preNode->BaseDllName);
        preNode = (PLDR_DATA_TABLE_ENTRY)preNode->InLoadOrderLinks.Flink;
    } while (preNode != selfNode);
    DriverObject->DriverUnload = UnloadDriver;
    return STATUS_SUCCESS;
}
//驱动卸载函数
void UnloadDriver(PDRIVER_OBJECT driver) {
    DbgPrint("驱动停止了。\r\n");
}
```

kill360主动防御

```c
#include <ntifs.h>

void UnloadDriver(PDRIVER_OBJECT driver);

typedef struct _LDR_DATA_TABLE_ENTRY {
    LIST_ENTRY InLoadOrderLinks;
    ULONG __Undefined1;
    ULONG __Undefined2;
    ULONG __Undefined3;
    ULONG NonPagedDebugInfo;
    ULONG DllBase;
    ULONG EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT __Undefined5;
    ULONG  __Undefined6;
    ULONG  CheckSum;
    ULONG  TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) {
    PLDR_DATA_TABLE_ENTRY selfNode = (PLDR_DATA_TABLE_ENTRY)DriverObject->DriverSection;
    PLDR_DATA_TABLE_ENTRY preNode = selfNode;

    UNICODE_STRING kernelName = { 0 };
    RtlInitUnicodeString(&kernelName, L"ntoskrnl.exe");

    do {
        if (preNode->BaseDllName.Length != 0 && RtlCompareUnicodeString(&preNode->BaseDllName, &kernelName, TRUE) == 0) {
            DbgPrint("已找到:%wZ\r\n", &preNode->BaseDllName);   
            break;
        }
        preNode = (PLDR_DATA_TABLE_ENTRY)preNode->InLoadOrderLinks.Flink;
    } while (preNode != selfNode);

    ULONG KernelBase = preNode->DllBase;
    ULONG KernelLimit = preNode->SizeOfImage;
	//特征码
    ULONG str1 = 0x3b08758b;
    ULONG str2 = 0x0248be8d;
    ULONG str3 = 0x0174868d;

    typedef NTSTATUS(*funcPspTerminateProcess)(PEPROCESS process, NTSTATUS ExitStatus);
    funcPspTerminateProcess PspTerminateProcess;

    for (ULONG i = KernelBase; i < KernelBase + KernelLimit; i++)
    {
        if (*(PULONG)i == str1)
        {
            if (*(PULONG)(i + 0x10) == str2)
            {
                if (*(PULONG)(i + 0x1c) == str3)
                {
                    PspTerminateProcess = (funcPspTerminateProcess)(i - 0xc);
                    break;
                }
            }
        }

    }

	DbgPrint("%p\r\n", PspTerminateProcess);
	
    PEPROCESS pEprocesszz = NULL;
    NTSTATUS status = PsLookupProcessByProcessId((HANDLE)956, &pEprocesszz);
    if (status != STATUS_SUCCESS) {
        DbgPrint(TEXT("获取进程的PEPROCESS失败\n"));
        return status;
    }

    status = PspTerminateProcess(pEprocesszz, 0);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint(TEXT("杀死进程失败\n"));
    }
    DbgPrint(TEXT("杀死进程成功\n"));
	
	DriverObject->DriverUnload = UnloadDriver;
    return STATUS_SUCCESS;
}
//驱动卸载函数
void UnloadDriver(PDRIVER_OBJECT driver) {
    DbgPrint("驱动停止了。\r\n");
}
```

<video src="./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/2023-04-07%2016-45-40.mkv"></video>

设备读写

ring0:

```c
#include <ntddk.h>

//设备名,0环用
#define DEVICE_NAME L"\\Device\\DayuDev"
//符号链接名,3环用
#define SYMBOLICLINK_NAME L"\\??\\DayuDevLnk"

#define OPER1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define OPER2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)

//函数声明
NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING RegPath);
VOID DriverUnload(PDRIVER_OBJECT pDriver);
NTSTATUS IrpCreateProc(PDEVICE_OBJECT pDevObj, PIRP pIrp);
NTSTATUS IrpCloseProc(PDEVICE_OBJECT pDevObj, PIRP pIrp);
NTSTATUS IrpDeviceControlProc(PDEVICE_OBJECT pDevObj, PIRP pIrp);

NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING RegPath)
{
	NTSTATUS status;
	ULONG uIndex = 0;
	PDEVICE_OBJECT pDeviceObj = NULL;

	UNICODE_STRING DeviceName;	//设备名,0环用
	UNICODE_STRING SymbolicLinkName;	//符号链接名,3环用

	//创建设备名称
	RtlInitUnicodeString(&DeviceName, DEVICE_NAME);
	//创建设备
	status = IoCreateDevice(pDriver, 0, &DeviceName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &pDeviceObj);
	if (status != STATUS_SUCCESS)
	{
		IoDeleteDevice(pDeviceObj);
		DbgPrint("设备创建失败.\n");
		return status;
	}
	DbgPrint("创建设备成功.\n");
	//设置交互数据的方式
	pDeviceObj->Flags |= DO_BUFFERED_IO;
	//创建符号链接
	RtlInitUnicodeString(&SymbolicLinkName, SYMBOLICLINK_NAME);
	IoCreateSymbolicLink(&SymbolicLinkName, &DeviceName);
	//设置分发函数
	pDriver->MajorFunction[IRP_MJ_CREATE] = IrpCreateProc;
	pDriver->MajorFunction[IRP_MJ_CLOSE] = IrpCloseProc;
	pDriver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IrpDeviceControlProc;
	//设置卸载函数
	pDriver->DriverUnload = DriverUnload;
	return STATUS_SUCCESS;

}

//卸载驱动
VOID DriverUnload(PDRIVER_OBJECT pDriver)
{
	UNICODE_STRING SymbolicLinkName;
	RtlInitUnicodeString(&SymbolicLinkName, SYMBOLICLINK_NAME);
	IoDeleteSymbolicLink(&SymbolicLinkName);
	IoDeleteDevice(pDriver->DeviceObject);
	DbgPrint("驱动卸载成功\n");
}

NTSTATUS IrpCreateProc(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
	DbgPrint("应用层连接设备.\n");

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	pIrp->IoStatus.Information = 0;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

	return STATUS_SUCCESS;
}

NTSTATUS IrpCloseProc(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
	DbgPrint("应用层断开连接设备.\n");

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	pIrp->IoStatus.Information = 0;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

NTSTATUS IrpDeviceControlProc(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
	DbgPrint("应用层:IrpDeviceControlProc.\n");
	NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;
	PIO_STACK_LOCATION pIrpStak;
	ULONG uIoControlCode;
	PVOID pIoBuffer;
	ULONG uInLength;
	ULONG uOutLength;
	ULONG uRead;
	ULONG uWrite;

	uRead = 0;
	uWrite = 0x12345678;
	//获取IRP数据
	pIrpStak = IoGetCurrentIrpStackLocation(pIrp);
	//获取控制码
	uIoControlCode = pIrpStak->Parameters.DeviceIoControl.IoControlCode;
	//获取缓冲区地址(输入输出是同一个)
	pIoBuffer = pIrp->AssociatedIrp.SystemBuffer;
	//Ring3发送数据的长度
	uInLength = pIrpStak->Parameters.DeviceIoControl.InputBufferLength;
	//Ring0发送数据的长度
	uOutLength = pIrpStak->Parameters.DeviceIoControl.OutputBufferLength;

	switch (uIoControlCode)
	{
	case OPER1:
		{
			DbgPrint("IrpDeviceControlProc -> OPER1...\n");
			pIrp->IoStatus.Information = 0;
			status = STATUS_SUCCESS;
			break;
		}
	case OPER2:
		{
			DbgPrint("IrpDeviceControlProc -> OPER2 输入字节数: %d\n", uInLength);
			DbgPrint("IrpDeviceControlProc -> OPER2 输出字节数: %d\n", uOutLength);
			//读取缓冲区
			memcpy(&uRead, pIoBuffer, 4);
			DbgPrint("IrpDeviceControlProc -> OPER2 uRead: %x\n", uRead);
			//写入缓冲区
			memcpy(pIoBuffer, &uWrite, 4);
			//设置状态
			pIrp->IoStatus.Information = 4;	//返回两字节
			status = STATUS_SUCCESS;
			break;

		}
	}

	pIrp->IoStatus.Status = status;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}
```

ring3:

```c
// test.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <stdio.h>
#include <Windows.h>
#include <winioctl.h>
#define SYMBOLICLINK_NAME L"\\\\.\\DayuDevLnk"
#define OPER1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define OPER2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IN_BUFFER_MAXLENGTH 4
#define OUT_BUFFER_MAXLENGTH 4

int main(int argc, char* argv[])
{
	HANDLE hDevice = CreateFileW(SYMBOLICLINK_NAME, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, 0);
	DWORD dwError = GetLastError();
	if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("获取设备句柄失败 %d.\n", dwError); // 如果返回1，请在驱动中指定 IRP_MJ_CREATE 处理函数
        getchar();
        return 1;
    }
    else
    {
        printf("获取设备句柄成功.\n");
    }

	// 测试通信
    DWORD dwInBuffer = 0x11111111;
    DWORD dwOutBuffer = 0xFFFFFFFF;
    DWORD dwOut;

	DeviceIoControl(hDevice, OPER2, &dwInBuffer, IN_BUFFER_MAXLENGTH, &dwOutBuffer, OUT_BUFFER_MAXLENGTH, &dwOut, NULL);
	printf("dwOutBuffer: %08X dwOut: %08X\n", dwOutBuffer, dwOut);
	CloseHandle(hDevice);
	getchar();

	return 0;
}
```

![image-20230407203335194](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230407203335194.png)

ring3 Inline hook

```c
// test.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <stdio.h>
#include <windows.h>

DWORD Argtmp = 0;
BYTE* ProcAddr = 0;    // 原函数地址
DWORD OldProtect = 0;  // 保存旧的内存保护
BYTE OldCmd[20] = { 0 }; // 存储原函数头部原始指令 在最后面构造返回到原函数的指令

BYTE* HookProcAddr = 0; // 钩子函数的地址

// 函数指针 将数据作为指令执行
typedef void (*POLDCMD)();
POLDCMD pOldCmd = (POLDCMD)(char*)OldCmd;
// printf的格式
//char* format = "%x";

DWORD add(DWORD a, DWORD b)
{
    return a + b;
}

void __declspec(naked) HookProc()
{
    // 保存现场
    /*
    0012FF00   00000246 //pushfd
    0012FF04   0012FF80
    0012FF08   0012B750
    0012FF0C   0012FF80
    0012FF10   0012FF24
    0012FF14   7FFDE000
    0012FF18   00401020  test.add
    0012FF1C   0000002B
    0012FF20   00401020  test.add   //pushad
    */
    // 保存现场
    __asm
    {
        pushad
        pushfd

        mov eax, esp
        add eax, 40
        mov eax, [eax]
        mov dword ptr ds : Argtmp, eax
    }

    // 获得参数1
    printf("a = %x\n", Argtmp);

    // 获得参数2
    __asm
    {
        mov eax, esp
        add eax, 44
        mov eax, [eax]
        mov dword ptr ds : Argtmp, eax
    }

    printf("b = %x\n", Argtmp);

    // 还原现场
    __asm
    {

        popfd
        popad

        // 执行原函数头部指令 并返回到原函数下一行继续执行
        jmp pOldCmd
    }
}

void InlineHook()
{   
    /*
    20:   DWORD add(DWORD a, DWORD b)
    21:   {
    00401020 55                   push        ebp
    00401021 8B EC                mov         ebp,esp
    00401023 83 EC 40             sub         esp,40h   //对齐指令,需要替换6个字节,jmp+地址是5个字节,然后再nop一个.
    00401026 53                   push        ebx
    00401027 56                   push        esi
    00401028 57                   push        edi
    00401029 8D 7D C0             lea         edi,[ebp-40h]
    0040102C B9 10 00 00 00       mov         ecx,10h
    00401031 B8 CC CC CC CC       mov         eax,0CCCCCCCCh
    00401036 F3 AB                rep stos    dword ptr [edi]
    22:       return a + b;
    00401038 8B 45 08             mov         eax,dword ptr [ebp+8]
    0040103B 03 45 0C             add         eax,dword ptr [ebp+0Ch]
    23:   }
    0040103E 5F                   pop         edi
    0040103F 5E                   pop         esi
    00401040 5B                   pop         ebx
    00401041 8B E5                mov         esp,ebp
    00401043 5D                   pop         ebp
    00401044 C3                   ret
    */
    // 获得需要挂钩的函数地址
    ProcAddr = (BYTE*)add + 1;  //00401005 E9 16 00 00 00       jmp         add (00401020)
    ProcAddr += *(DWORD*)ProcAddr + 4;  //00401020  DWORD add(DWORD a, DWORD b)
    // 修改内存保护
    VirtualProtect(ProcAddr, 6, PAGE_EXECUTE_READWRITE, &OldProtect);   //修改6个字节的保护属性,向上取整为4kb.
    // 将被覆盖的指令复制到数组中
    strncpy((char*)OldCmd, (char*)ProcAddr, 6); //保存指令

    // 数组末尾添上跳转指令 用于返回到被挂钩的函数
    OldCmd[6] = 0xE9;   //E9,jmp
    *(DWORD*)&OldCmd[7] = (DWORD)(ProcAddr + 6) - (DWORD)&OldCmd[6] - 5;    //跳转地址

    // 获得钩子函数的地址
    HookProcAddr = (BYTE*)HookProc + 1;
    HookProcAddr += *(DWORD*)HookProcAddr + 4;  //hook func addr
    // 修改原函数的头部 跳转到钩子函数
    ProcAddr[0] = 0xE9;
    *(DWORD*)&ProcAddr[1] = HookProcAddr - ProcAddr - 5;    //jmp hook func

    // 跳转指令只占五个字节 原函数头部三行指令占六个字节 因此将多余字节填充为nop
    ProcAddr[5] = 0x90; //nop
    /*
    20:   DWORD add(DWORD a, DWORD b)
    21:   {
    00401020 E9 2B 00 00 00       jmp         HookProc (00401050)
    00401025 90                   nop
    */
}

void UnInlineHook()
{
    // 判断函数是否被挂钩
    if (ProcAddr[0] == 0xE9)
    {
        strncpy((char*)ProcAddr, (char*)OldCmd, 6);
    }
}

int main()
{
    DWORD sum;

    // 挂钩
    InlineHook();

    sum = add(1, 2);
    printf("sum = %x\n", sum);

    // 脱钩
    // UnInlineHook();

    sum = add(3, 4);
    printf("sum = %x\n", sum);

    return 0;
}
```

ring0 Inline hook

```c
#include <ntddk.h>
#include <ntstatus.h>

PUCHAR pNtOpenProcess;
UCHAR  OldCmd[20] = { 0 };
//函数指针 用于将数据作为指令执行
typedef VOID(*POLDCMD)();
POLDCMD pOldCmd = (POLDCMD)(PUCHAR)OldCmd;

PCHAR format = "%x %x %x %x \r\n";

typedef NTSTATUS(*NTOPENPROCESS)(
	PHANDLE ProcessHandle,
	ACCESS_MASK DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes,
	PCLIENT_ID ClientId);

typedef struct _KSYSTEM_SERVICE_TABLE
{
	PULONG  ServiceTableBase;			// 服务函数地址表基址  
	PULONG  ServiceCounterTableBase;	// SSDT函数被调用的次数
	ULONG   NumberOfService;			// 服务函数的个数  
	PULONG   ParamTableBase;			// 服务函数参数表基址   
} KSYSTEM_SERVICE_TABLE, * PKSYSTEM_SERVICE_TABLE;

typedef struct _KSERVICE_TABLE_DESCRIPTOR
{
	KSYSTEM_SERVICE_TABLE   ntoskrnl;		// ntoskrnl.exe 的服务函数  
	KSYSTEM_SERVICE_TABLE   win32k;			// win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持)  
	KSYSTEM_SERVICE_TABLE   notUsed1;
	KSYSTEM_SERVICE_TABLE   notUsed2;
}KSERVICE_TABLE_DESCRIPTOR, * PKSERVICE_TABLE_DESCRIPTOR;

// KeServiceDescriptorTable 是 ntoskrnl.exe 所导出的全局变量 申明一下就可以直接使用了
extern PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;

VOID PageProtectOn()
{
	__asm {//开启内存保护
		mov  eax, cr0
		or eax, 10000h
		mov  cr0, eax
		sti
	}
}

VOID PageProtectOff()
{
	__asm {//关闭内存保护
		cli
		mov  eax, cr0
		and eax, not 10000h
		mov  cr0, eax
	}
}

VOID __declspec(naked) HookProc() {
	__asm
	{
		//保存现场
		pushad
		pushfd

		mov eax, esp
		add eax, 40		//eflags + 8个通用寄存器 + 返回地址
		add eax, 12		//定位到最后一个参数
		push[eax]		//ClientId
		push[eax - 0x4]	//ObjectAttributes
		push[eax - 0x8]	//DesiredAccess
		push[eax - 0xC]	//ProcessHandle
		push format
		call DbgPrint
		add esp, 20

		//还原现场
		popfd
		popad

		//调用原本的指令，然后返回到原函数
		jmp pOldCmd
	}
}

NTSTATUS InlineHook()
{
	NTSTATUS status;
	status = STATUS_SUCCESS;

	PageProtectOff();

	//保存原来的指令
	pNtOpenProcess = (PUCHAR)KeServiceDescriptorTable->ntoskrnl.ServiceTableBase[0x7A];
	/*
	PAGE:004A8956 68 C4 00 00 00                push    0C4h
	PAGE:004A895B 68 50 CC 41 00                push    offset stru_41CC50
	PAGE:004A8960 E8 8E 34 F6 FF                call    __SEH_prolog
	*/
	RtlMoveMemory(OldCmd, pNtOpenProcess, 5);	//刚好5个

	//构造回去的指令，用于返回到原函数
	OldCmd[5] = 0xE9;
	*(PULONG)&OldCmd[6] = ((ULONG)pNtOpenProcess + 5) - (ULONG)&OldCmd[5] - 5;

	//内核函数不存在中间人（call后通过jmp跳转），函数地址为实际地址
	pNtOpenProcess[0] = 0xE9;
	*(PULONG)&pNtOpenProcess[1] = (ULONG)HookProc - (ULONG)pNtOpenProcess - 5;

	PageProtectOn();

	return status;
}

NTSTATUS UnInlineHook()
{
	NTSTATUS status;
	status = STATUS_SUCCESS;

	if (pNtOpenProcess[0] == 0xE9)
	{
		PageProtectOff();
		RtlMoveMemory(pNtOpenProcess, OldCmd, 5);
		PageProtectOn();
	}

	return status;
}

//卸载函数
VOID DriverUnload(PDRIVER_OBJECT driver)
{
	//卸载驱动时脱钩
	UnInlineHook();

	DbgPrint("驱动程序已停止.\r\n");
}

//驱动程序入口函数，相当于控制台的main函数
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
	DbgPrint("驱动程序已运行.\r\n");
	//运行驱动时挂钩
	InlineHook();

	//设置一个卸载函数  便于退出
	DriverObject->DriverUnload = DriverUnload;

	return STATUS_SUCCESS;
}
```

重载内核(还没hook)

```c
/*
重载内核
1.申请内存,按内存对齐展开
2.根据重定位表修复全局变量
3.修复IAT表(修复导入表的说法不准确)
4.山寨系统服务表
5.狸猫换太子(Hook KiFastCallEntry)
*/
#include <ntifs.h>
#include <ntimage.h>

typedef struct _KSYSTEM_SERVICE_TABLE
{
	PULONG ServiceTableBase;			// 函数地址表
	PULONG ServiceCounterTableBase;		// SSDT 函数被调用的次数
	ULONG NumberOfService;				// 函数个数
	PULONG ParamTableBase;				// 函数参数表
} KSYSTEM_SERVICE_TABLE, * PKSYSTEM_SERVICE_TABLE;

__declspec(dllimport) KSYSTEM_SERVICE_TABLE KeServiceDescriptorTable;

ULONG OrigImage = 0x804D8000;
KSYSTEM_SERVICE_TABLE* pNewSSDT;
PVOID pVirtualPointerTmp;

void LoadKernel();
void FixBaseRelocationTable(PVOID pNewImage);
void MakeNewSSDT(PVOID pNewImage);
void UnloadDriver(PDRIVER_OBJECT driver);

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
	DbgPrint("驱动已加载.\n");
	DbgPrint("开始重载内核.\n");

	LoadKernel();

	DriverObject->DriverUnload = UnloadDriver;    //为驱动指定卸载函数
	return STATUS_SUCCESS;
}

void LoadKernel()
{
	//1.申请内存, 按内存对齐展开
	NTSTATUS status;
	UNICODE_STRING KernelPath;
	HANDLE hFile;
	OBJECT_ATTRIBUTES ObjAttr;
	IO_STATUS_BLOCK IoStatusBlock;
	LARGE_INTEGER FileOffset;
	IMAGE_DOS_HEADER ImageDosHeader;
	IMAGE_NT_HEADERS32 ImageNtHeader;
	PIMAGE_SECTION_HEADER pImageSectionHeader;
	PVOID pVirtualPointer;
	ULONG uLoop;
	ULONG SectionVirtualAddress;
	ULONG SectionSize;

	InitializeObjectAttributes(&ObjAttr, &KernelPath, OBJ_CASE_INSENSITIVE, NULL, NULL);

	RtlInitUnicodeString(&KernelPath, L"\\??\\C:\\WINDOWS\\system32\\ntoskrnl.exe");
	status = ZwCreateFile(&hFile, FILE_ALL_ACCESS, &ObjAttr, &IoStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN, FILE_NON_DIRECTORY_FILE, NULL, 0);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("打开内核文件<失败>.\n");
		DbgPrint("%x", status);
		ZwClose(hFile);
		return;
	}
	DbgPrint("打开内核文件<成功>.\n");

	FileOffset.QuadPart = 0;	//文件偏移量位0,dos.
	status = ZwReadFile(hFile, NULL, NULL, NULL, &IoStatusBlock, &ImageDosHeader, sizeof(IMAGE_DOS_HEADER), &FileOffset, 0);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("读取dosHeader<失败>.\n");
		DbgPrint("%x", status);
		ZwClose(hFile);
		return;
	}

	FileOffset.QuadPart += ImageDosHeader.e_lfanew;
	status = ZwReadFile(hFile, NULL, NULL, NULL, &IoStatusBlock, &ImageNtHeader, sizeof(IMAGE_NT_HEADERS32), &FileOffset, 0);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("读取ntHeader<失败>.\n");
		DbgPrint("%x", status);
		ZwClose(hFile);
		return;
	}

	FileOffset.QuadPart += sizeof(IMAGE_NT_HEADERS);
	pImageSectionHeader = (IMAGE_SECTION_HEADER*)ExAllocatePool(NonPagedPool, sizeof(IMAGE_SECTION_HEADER) * ImageNtHeader.FileHeader.NumberOfSections);
	status = ZwReadFile(hFile, NULL, NULL, NULL, &IoStatusBlock, pImageSectionHeader, \
		sizeof(IMAGE_SECTION_HEADER) * ImageNtHeader.FileHeader.NumberOfSections, &FileOffset, 0);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("读取sectionHeader<失败>.\n");
		DbgPrint("%x", status);
		ExFreePool(pImageSectionHeader);
		ZwClose(hFile);
		return;
	}
	//拉伸PE
	pVirtualPointer = ExAllocatePool(NonPagedPool, ImageNtHeader.OptionalHeader.SizeOfImage);
	RtlZeroMemory(pVirtualPointer, ImageNtHeader.OptionalHeader.SizeOfImage);
	/*
	RtlCopyMemory(pVirtualPointer, &ImageDosHeader, sizeof(IMAGE_DOS_HEADER));
	RtlCopyMemory((PVOID)((UCHAR)pVirtualPointer + ImageDosHeader.e_lfanew), &ImageNtHeader, sizeof(IMAGE_NT_HEADERS));
	RtlCopyMemory((PVOID)((ULONG)pVirtualPointer + ImageDosHeader.e_lfanew + sizeof(IMAGE_NT_HEADERS)), pImageSectionHeader, \
		sizeof(IMAGE_SECTION_HEADER) * ImageNtHeader.FileHeader.NumberOfSections);
	//可能复制不完全,应该直接复制SizeOfHeaders
	*/
	FileOffset.QuadPart = 0;
	status = ZwReadFile(hFile, NULL, NULL, NULL, &IoStatusBlock, pVirtualPointer, ImageNtHeader.OptionalHeader.SizeOfHeaders, &FileOffset, 0);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("Headers数据读取<失败>.\n");
		DbgPrint("%x", status);
		ExFreePool(pImageSectionHeader);
		ExFreePool(pVirtualPointer);
		ZwClose(hFile);
		return;
	}
	
	for (uLoop = 0; uLoop < ImageNtHeader.FileHeader.NumberOfSections; uLoop++)
	{
		SectionVirtualAddress = pImageSectionHeader[uLoop].VirtualAddress;//对应区段相对偏移
		if (pImageSectionHeader[uLoop].Misc.VirtualSize > pImageSectionHeader[uLoop].SizeOfRawData)
		{
			SectionSize = pImageSectionHeader[uLoop].Misc.VirtualSize;//取最大的占用空间
		}
		else
		{
			SectionSize = pImageSectionHeader[uLoop].SizeOfRawData;
		}		
		FileOffset.QuadPart = pImageSectionHeader[uLoop].PointerToRawData;//对应区段的超始地址
		status = ZwReadFile(hFile, NULL, NULL, NULL, &IoStatusBlock, (PVOID)((ULONG)pVirtualPointer + SectionVirtualAddress), SectionSize, &FileOffset, 0);
		if (!NT_SUCCESS(status))
		{
			DbgPrint("uLoop:%x.\n", uLoop);
			DbgPrint("节表数据读取<失败>.\n");
			DbgPrint("%x", status);
			ExFreePool(pImageSectionHeader);
			ExFreePool(pVirtualPointer);
			ZwClose(hFile);
			return;
		}
	}
	//拉伸完成
	ExFreePool(pImageSectionHeader);
	DbgPrint("pVirtualPointer: %x\n", pVirtualPointer);
	FixBaseRelocationTable(pVirtualPointer);
	MakeNewSSDT(pVirtualPointer);
	//DbgBreakPoint();
	//ExFreePool(pVirtualPointer);
	pVirtualPointerTmp = pVirtualPointer;
	ZwClose(hFile);
}

void FixBaseRelocationTable(PVOID pNewImage)
{
	//2.根据重定位表修复全局变量
	PIMAGE_DOS_HEADER pImageDosHeader;
	PIMAGE_NT_HEADERS pImageNtHeader;
	ULONG OldImageBase;
	IMAGE_DATA_DIRECTORY ImageDataDirectory;
	PIMAGE_BASE_RELOCATION pImageBaseRelocation;
	ULONG uRelocTableSize;
	USHORT* pTypeOffset;
	ULONG uIndex;
	ULONG Type;
	ULONG* uRelocAddress;

	//定位header
	pImageDosHeader = (PIMAGE_DOS_HEADER)pNewImage;
	pImageNtHeader = (PIMAGE_NT_HEADERS)((ULONG)pNewImage + pImageDosHeader->e_lfanew);
	OldImageBase = pImageNtHeader->OptionalHeader.ImageBase;
	//定位重定位表
	ImageDataDirectory = pImageNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
	if (ImageDataDirectory.VirtualAddress == NULL)
	{
		DbgPrint("没有找到重定位表.\n");
		return;
	}
	pImageBaseRelocation = (PIMAGE_BASE_RELOCATION)((ULONG)pNewImage + ImageDataDirectory.VirtualAddress);
	//开始修复重定位表
	while ((pImageBaseRelocation->VirtualAddress != 0) && (pImageBaseRelocation->SizeOfBlock != 0))
	{
		pTypeOffset = (USHORT*)(pImageBaseRelocation + 8);
		uRelocTableSize = (pImageBaseRelocation->SizeOfBlock - 8) / 2;
		for (uIndex = 0; uIndex < uRelocTableSize; uIndex++)
		{
			Type = pTypeOffset[uIndex] >> 12;
			if (Type == 3)
			{
				uRelocAddress = (ULONG*)((ULONG)(pTypeOffset[uIndex] & 0x0fff) + pImageBaseRelocation->VirtualAddress + (ULONG)pNewImage);
				*uRelocAddress = *uRelocAddress + (OrigImage - OldImageBase);	//这里和普通exe修复地址不一样,需要用到现在内核的地址,得遍历链表才行,现在先写死.
			}

		}
		pImageBaseRelocation = (IMAGE_BASE_RELOCATION*)((ULONG)pImageBaseRelocation + pImageBaseRelocation->SizeOfBlock);
	}
}

void MakeNewSSDT(PVOID pNewImage)
{
	//SSTD表就在内核里面
	ULONG uNewKernelInc;
	ULONG uOffset;
	ULONG uIndex;
	//新内核地址-老内核地址，得到相对偏移
	uNewKernelInc = (ULONG)pNewImage - OrigImage;
	//老内核的ssdt指针加上相对偏移，得到新内核的ssdt指针
	pNewSSDT = (KSYSTEM_SERVICE_TABLE*)((ULONG)&KeServiceDescriptorTable + uNewKernelInc);

	if (!MmIsAddressValid(pNewSSDT))
	{
		DbgPrint("找不到NewSSTD");
		return;
	}
	//数量相同
	pNewSSDT->NumberOfService = KeServiceDescriptorTable.NumberOfService;
	//计算相对函数地址
	uOffset = (ULONG)KeServiceDescriptorTable.ServiceTableBase - OrigImage;
	//得到新的ssdt函数表地址
	pNewSSDT->ServiceTableBase = (ULONG*)((ULONG)pNewImage + uOffset);
	if (!MmIsAddressValid(pNewSSDT->ServiceTableBase))
	{
		DbgPrint("pNewSSDT->ServiceTableBase: %x", pNewSSDT->ServiceTableBase);
		return;
	}
	//依次遍历
	for (uIndex = 0; uIndex < pNewSSDT->NumberOfService; uIndex++)
	{//新的函数地址再加上相对加载地址，得到现在的ssdt函数地址
		pNewSSDT->ServiceTableBase[uIndex] += uNewKernelInc;
	}
}



void UnloadDriver(PDRIVER_OBJECT driver) {

	ExFreePool(pVirtualPointerTmp);
	DbgPrint("驱动停止了.\n");
}
```

