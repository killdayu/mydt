# 滴水三期中级笔记

看了视频没怎么理清楚,所以写笔记理一下思路.可能以后玩会了就不写笔记了.

有2个原则:

1.只写我的理解,没理解到的不写.

2.先写通用的,后面要用到了再写特殊的.

------

环境配置:

 [双机调试_windbg.pdf](双机调试_windbg.pdf) 

## 1.保护模式

x86 CPU的3个模式:实模式,保护模式和虚拟8086模式.

建议先参考王爽的汇编语言,我3年前的笔记https://note.youdao.com/s/y3jcBKz.

------

由于历史遗留原因,8086所采用的20位地址总线,寻址地址达到了2的20次方,即1MB.但是由于采用的是16位架构,其他通用寄存器只能达到2的16次方寻址,即64KB.所以采用了段加偏移的方式来寻址,即段地址x16+偏移地址=物理地址.这一点在x86保护模式下也采用了,只不过32位的通用寄存器可以直接寻址所有地址,段寄存器的主要作用变为了权限控制,比如代码段可读可执行不可写,数据段可读可写不可执行.

在x86架构下的段寄存器有96位,但是只有16位可以直接改变.剩下的80位不能直接改变.

结构如下:

```c++
class SegMent
{
public:
	WORD Selector;		//段选择子

private:
	WORD Attributes;	//权限
	DWORD Base;			//基址
	DWORD Limit;		//段长度

};
```

由于不能直接改变段寄存器,所以我们只能间接的通过一张表来进行更改段寄存器,即全局描述符表(GPT,Global Descriptor Table),还有另外一张表,局部描述符表(LPT,Local Descriptor Table),Windows并没有用上.

```assembly
mov ax,es	//复制Selector到ax.
mov es,ax	//通过Selector查找GPT,然后加载GTPT对于的表到es.
//除了mov指令还有LES,LSS,LDS,LFS,LGS等指令可以修改段寄存器,还没有学到,先不讨论.
```

GPT表的位置,大小存储在gdtr(48位)寄存器中.

windbg:

```
kd> r gdtr
gdtr=8003f000
kd> r gdtl
gdtl=000003ff
kd> dq 8003f000 l10
ReadVirtual: 8003f000 not properly sign extended
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 00000000`00000000
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff
```

------

段选择子:

16位,指向了定义该段的段描述符. 

![image-20230326202402680](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230326202402680.png)

```
RPL:
请求特权级别.

TI:
TI=0 查GDT表.	//因为Windows只使用了GDT表,所以TI总为1.
TI=1 查LDT表.

Index:
表的索引,0开始.
```

EX:

| 0x23  | 0010 0011 |      |
| ----- | --------- | ---- |
| Index | TI        | RPL  |
| 00100 | 0         | 11   |
| 0x2B  | 0010 1011 |      |
| Index | TI        | RPL  |
| 00101 | 0         | 11   |
| 0x30  | 0011 0000 |      |
| Index | TI        | RPL  |
| 00110 | 0         | 00   |
| 0x3B  | 0011 1011 |      |
| Index | TI        | RPL  |
| 00110 | 0         | 11   |
| 0x53  | 0101 0011 |      |
| Index | TI        | RPL  |
| 01010 | 0         | 11   |

------

段描述符:

32位,定义了该段的属性.

![image-20230326203632589](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230326203632589.png)

```
P->G->S->TYPE.

P(段限制):
定义了该段描述符是否有效.
1	有效.
0	无效.

G(粒度):
定义了Segment Limit的单位
0	byte,最大为0x000FFFFF,1MB.
1	4kb,最大为0xFFFFFFFF,4GB.

S(描述符类型):
0	system.
1	code或者data.

TYPE(段类型):
和S有关,此处略.
```

TYPE:

S = 1:

![image-20230326210024318](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230326210024318.png)

```
Data:
    A(accessed):
    访问位.
    W(Write):
    可写位.
    E(expand-down):
    拓展位.
```

向上拓展和向下拓展,红色为段空间,即向上拓展和向下拓展互为补集,全集的大小和D/B有关(16/32位寻址方式).

![image-20230326210514299](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230326210514299.png)

```
Code:
    A(accessed):
    访问位.
    R(Read):
    可读位.
    C(conforming):
    一致位,此处略.
```

S = 0:

![image-20230326210109852](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230326210109852.png)

EX:

```
kd> dq 8003f000 l10
ReadVirtual: 8003f000 not properly sign extended
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 00000000`00000000
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff

段选择子为0x23,00100 0 11,索引为4,00cff300`0000ffff.P位所在的f大于等于8,即P位为1,该段描述符有效,G位为1,S位为1,是code/data段,TYPE为3,Data段,权限为:Read/Write,accessed.
Base:00000000
Atrribute:cff3
Limit:0xffffffff

段选择子为0x2B,00101 01 1,索引为5,80008b04`200020ab.P位所在的8等于大于8,即P位为1,该段描述符有效,G位为0,S位为0,是system段,TYPE为11,权限为:32-Bit TSS(Busy).
Base:80042000
Atrribute:008b
Limit:0x0ffff000

段选择子为0x30,00110 0 00,索引为6,ffc093df`f0000001.P位所在的9等于大于8,即P位为1,该段描述符有效,G位为1,S位为1,是code/data段,TYPE为3,Data段,权限为:Read/Write,accessed.
Base:ffdff000
Atrribute:c093
Limit:0x00001fff

段选择子为0x3B,00111 0 11,索引为7,0040f300`00000fff.P位所在的f等于大于8,即P位为1,该段描述符有效,G位为0,S位为1,是code/data段,TYPE为3,Data段,权限为:Read/Write,accessed.
Base:00000000
Atrribute:40f3
Limit:0x00000fff

段选择子为0x53,01010 0 11,索引为10,80008955`27000068.P位所在的8等于大于8,即P位为1,该段描述符有效,G位为0,S位为0,是system段,TYPE为9,权限为:Available.
Base:80552700
Atrribute:0089
Limit:0x00000068
```

------

段权限检查:

GPL(Global Privilege Level):
全局特权级别,GDT表里面的段描述符

CPL(Current Privilege Level):
当前特权级别,当前CS段选择子后2位

RPL(Requested Privilege Level):
请求特权级别,要使用的段选择子后2位

```
数据段的权限检查：
CPL <= DPL 并且 RPL <= DPL (数值上的比较)

kd> dq 8003f000
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 7f40f3fd`f0000fff
8003f040  0000f200`0400ffff 00000000`00000000
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff

mov ax,0xB
mov es,eax	//1011->1 0 11->00cf9b00`0000ffff,dpl为0,所以执行后权限检查不通过,就会触发异常,跳转到ntdll
```

------

代码跨段:

本质就是修改CS段寄存器,和EIP一样,涉及到代码的寄存器都无法通过指令直接改变.修改EIP可以使用jcc,call,ret等指令,CS段寄存器也一样,只不过是长跳转,jcc far,call far,retf等.

```
jmp 0x20:0x004183d7	//段选择子:偏移,即EIP(base通常为0).

1.段选择子拆分:
0x20->00100 0 00
2.GDT表拿到段描述符:
四种情况可以跳转:代码段,调用门,TSS任务段,任务门.这里只实验代码段.
3.权限检查:
非一致代码段:CPL == DPL && RPL <= DPL
一致代码段:CPL >= DPL
4.加载段描述符:
将段描述符加载到CS
5.代码执行:
EIP:CS.base + offset.
然后执行CS:EIP

一致位(conforming):
S为1,TYPE大于等于12,就为一致性代码段.

总结：
对于一致代码段:也就是共享的段
	特权级高的程序不允许访问特权级低的数据:核心态不允许访问用户态的数据
	特权级低的程序可以访问到特权级高的数据,但特权级不会改变:用户态还是用户态

对于普通代码段:也就是非一致代码段
	只允许同级访问
	绝对禁止不同级别的访问:核心态不是用户态,用户态也不是核心态.

直接对代码段进行JMP或者CALL的操作,无论目标是一致代码段还是非一致代码段,CPL都不会发生改变.如果要提升CPL的权限,只能通过调用门.
```

```
kd> dq 8003f000
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 7f40f3fd`f0000fff
8003f040  0000f200`0400ffff 00000000`00000000
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff
```

00cffb00`0000ffff为非一致代码段,CPL(3) == DPL(3) && RPL <= DPL(3),构造段选择子,0x11011. 

```
jmp far 001b:004183fd	//OK
jmp far 0008:004183fd	//ERROR
```

8003f048:00cfff00`0000ffff为一致代码段,CPL(3) >= DPL(0)

```
kd> eq 8003f048 00cfff00`0000ffff
WriteVirtual: 8003f048 not properly sign extended
kd> dq 8003f000
ReadVirtual: 8003f000 not properly sign extended
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 00cfff00`0000ffff
8003f050  00000000`0000ffff 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff

jmp far 004b:004183fd	//OK
```

![image-20230327213902570](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230327213902570.png)

------

长调用堆栈图:

指令格式：CALL  CS:EIP(EIP是废弃的)

1.跨段不提权:CPL权限并不发生改变,所以堆栈不变.

![image-20230329092803222](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230329092803222.png)

2.跨段并提权:CPL会改变,所以堆栈的特权级别也改变.

![image-20230329093028707](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230329093028707.png)

------

EX:

```c
#include "stdafx.h"
#include <windows.h>

void __declspec(naked) GetRegister()
{
	__asm
	{
		int 3

		retf
	}
}



int main(int argc, char* argv[])
{
	char buff[6];
	*(DWORD*)&buff[0] = 0x12345678;
	*(WORD*)&buff[4] = 0x48;
	__asm
	{
		call fword ptr[buff]
	}

	getchar();

	return 0;
}
```

![image-20230329103049437](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230329103049437.png)

![image-20230329103219542](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230329103219542.png)

```c
#include "stdafx.h"
#include <windows.h>

BYTE GDT[6] = {0};
DWORD dwH2GValue;

void __declspec(naked) GetRegister()
{
	__asm
	{
		pushad
		pushfd

		mov eax,0x8003f000
		mov ebx,[eax]
		mov dwH2GValue,ebx
		sgdt GDT

		popfd
		popad
		retf
	}
}

void PrintRegister()
{
	DWORD GDT_ADDR = *(PDWORD)(&GDT[2]);
	WORD GDT_LIMIT = *(PWORD)(&GDT[0]);

	printf("%x %x %x\n", dwH2GValue, GDT_ADDR, GDT_LIMIT);
}

int main(int argc, char* argv[])
{
	char buff[6];
	*(DWORD*)&buff[0] = 0x12345678;
	*(WORD*)&buff[4] = 0x48;
	__asm
	{
		call fword ptr[buff]
	}

	PrintRegister();
	getchar();

	return 0;
}
```

![image-20230329105047862](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230329105047862-1680058248632-1.png)

------

```c
#include "stdafx.h"
#include <windows.h>

DWORD x, y, z;

void __declspec(naked) GetRegister()
{
	__asm
	{
		pushad
		pushfd
		
		mov eax,[esp+0x24+0x8+0x8]	//0x24是pushad,pushfd进去的9个寄存器,0x8是EIP,CS.push进去的参数在中间,然后末尾是ESP,CS.
		mov dword ptr ds:[x],eax
		mov eax,[esp+0x24+0x8+0x4]
		mov dword ptr ds:[y],eax
		mov eax,[esp+0x24+0x8+0x0]
		mov dword ptr ds:[z],eax
		mov eax,0x0040db20
		mov dword ptr [esp+0x24],eax

		popfd
		popad
		retf 0xC
	}
}

void PrintRegister()
{
	printf("%x %x %x\n", x, y, z);
}

void print666()
{
	while(true)
	{
		Sleep(1000);
		printf("666");
	}
}

int main(int argc, char* argv[])
{
	char buff[6];
	*(DWORD*)&buff[0] = 0x12345678;
	*(WORD*)&buff[4] = 0x48;
	__asm
	{
		push 1
		push 2
		push 3
		call fword ptr[buff]
	}

	PrintRegister();
	getchar();

	return 0;
}
```

------

中断门:

```c
#include "stdafx.h"
#include <windows.h>

DWORD dwH2GValue;

void __declspec(naked) GetRegister()
{
	__asm
	{	
        int 3
		/*
		只能
        mov eax,0x12345678
        mov eax,[eax]
        不能直接
        mov eax,[0x12345678]  
		*/
		mov eax,0x8003f400		//mov eax,[0x8003f400]
		mov ebx,[eax]
		mov dwH2GValue,ebx

		iretd
	}
}

void PrintRegister()
{
	printf("%x \n", dwH2GValue);
}

int main(int argc, char* argv[])
{
	__asm
	{
		INT 0x20
	}

	PrintRegister();

	return 0;
}
```

![image-20230402150310592](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230402150310592.png)

 EIP->CS->EFL->ESP->SS

![img](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/1197364-20200712230227891-1208895313.png)

中断门和调用门的除了流程之外的区别是:

1.中断门的权限校验在IDT中,调用门在GDT.

2.中断门调用时堆栈会多保存EFL寄存器.

3.中断门不能传递参数.

------

陷阱门:

![image-20230402150745462](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230402150745462.png)

![img](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/1197364-20200719110036207-1537688390.png)

陷阱门与中断门唯一的不同就是ELF中的IF位,中断门执行后IF设置为0,陷阱门执行后IF不变.

------

任务状态段 TSS(Task State Segment):

同时改变很多寄存器的值.

![image-20230402192807473](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230402192807473.png)

TR寄存器:

LTR(Load TR):

用LTR指令去装载的话 仅仅是改变TR寄存器的值(96位) 并没有真正改变TSS 

LTR指令只能在系统层使用

加载后TSS段描述符会状态位会发生改变

STR(Save TR):

如果用STR去读的话，只读了TR的16位 也就是选择子

```c
// TSS.cpp : Defines the entry point for the console application.
//
 
#include <stdlib.h>
#include <stdio.h>
 
 
void __declspec(naked) EipFunction()
{
	__asm
	{
		int 3;   //便于内核调试器断下
		push ebp;
		mov ebp, esp;
 
		
	}
}
 
 
int main(int argc, char* argv[])
{
	char espBuffer[0x30] = { 0 }; //开辟空间构建TSS内存的栈顶
	printf("Please Input Cr3 Value \r\n");
	unsigned int Cr3Value = 0;
	scanf("%d", &Cr3Value);
	//构建TSS的内存
	unsigned int TssMemory[0x64] = {
	0x00000000,// Previous TaskLink 操作系统会给写入
	0x00000000,// esp 0
	0x00000000,// ss  0
	0x00000000,// esp 1
	0x00000000,// ss  1
	0x00000000,// esp 2
	0x00000000,// ss  2
	(unsigned int)Cr3Value,
	(unsigned int)EipFunction,// EIP              执行你函数的地址.EIP指向.这样才可以执行你的函数
	0x00000000,// eflags 
	0x12345678,// eax
	0x87654321,// ecx
	0x11223344,// edx
	0x44332211,// ebx              寄存器随便给.便于调试的时候更直观的看到
	(unsigned int)espBuffer,	// esp              栈顶的值.需要我们指定
	0x00000000,// ebp              栈底的值
	0x00000000,// esi
	0x00000000,// edi
	0x00000023,// es				段寄存器我们也要给 如果切换到内核则按照内核中的给.
	0x00000008,// cs				0环的代码段选择子. 如果想要切换rign3就给ring3的. 可以windbg调试
	0x00000010,// ss                同cs一样.ss与cs必须在同一代码段下
	0x00000023,// ds
	0x00000030,// fs
	0x00000000,// gs
	0x00000000,// LDT
	0x20ac0000,// Io              这个根据Windbg调试得出来.看一下填写即可.
	};
 
	printf("TSS内存的地址为 : %p \r\n", TssMemory);     //输出一下TSS内存的地址. 便于构造段描述符.
	fflush(stdin);
    getchar();
	char FarAddress[6] = { 0 };//构造我们的远call 指令.同调用门一样
	//call far 段选择子:eip 
	*(unsigned int*)&FarAddress[0] = 0x00000000; //EIP在远call的时候不用.随便给.
	*(unsigned short*)&FarAddress[4] = 0x48;    //构造的TSS段在GDT表中的段选择子.
	__asm
	{
		call fword ptr[FarAddress];
	}
	printf("over _ \r\n");
	system("pause");
	return 0;
}
```

需要TSS表在连续的页上,有点靠运气,我蓝屏好几次都没成功.
