# 滴水三期中级笔记

看了视频没怎么理清楚,所以写笔记理一下思路.可能以后玩会了就不写笔记了.

有2个原则:

1.只写我的理解,没理解到的不写.

2.先写通用的,后面要用到了再写特殊的.

------

环境配置:

 [双机调试_windbg.pdf](双机调试_windbg.pdf) 

## 1.保护模式

x86 CPU的3个模式:实模式,保护模式和虚拟8086模式.

建议先参考王爽的汇编语言,我3年前的笔记https://note.youdao.com/s/y3jcBKz.

------

由于历史遗留原因,8086所采用的20位地址总线,寻址地址达到了2的20次方,即1MB.但是由于采用的是16位架构,其他通用寄存器只能达到2的16次方寻址,即64KB.所以采用了段加偏移的方式来寻址,即段地址x16+偏移地址=物理地址.这一点在x86保护模式下也采用了,只不过32位的通用寄存器可以直接寻址所有地址,段寄存器的主要作用变为了权限控制,比如代码段可读可执行不可写,数据段可读可写不可执行.

在x86架构下的段寄存器有96位,但是只有16位可以直接改变.剩下的80位不能直接改变.

结构如下:

```c++
class SegMent
{
public:
	WORD Selector;		//段选择子

private:
	WORD Attributes;	//权限
	DWORD Base;			//基址
	DWORD Limit;		//段长度

};
```

由于不能直接改变段寄存器,所以我们只能间接的通过一张表来进行更改段寄存器,即全局描述符表(GPT,Global Descriptor Table),还有另外一张表,局部描述符表(LPT,Local Descriptor Table),Windows并没有用上.

```assembly
mov ax,es	//复制Selector到ax.
mov es,ax	//通过Selector查找GPT,然后加载GTPT对于的表到es.
//除了mov指令还有LES,LSS,LDS,LFS,LGS等指令可以修改段寄存器,还没有学到,先不讨论.
```

GPT表的位置,大小存储在gdtr(48位)寄存器中.

windbg:

```
kd> r gdtr
gdtr=8003f000
kd> r gdtl
gdtl=000003ff
kd> dq 8003f000 l10
ReadVirtual: 8003f000 not properly sign extended
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 00000000`00000000
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff
```

------

段选择子:

16位,指向了定义该段的段描述符. 

![image-20230326202402680](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230326202402680.png)

```
RPL:
请求特权级别.

TI:
TI=0 查GDT表.	//因为Windows只使用了GDT表,所以TI总为1.
TI=1 查LDT表.

Index:
表的索引,0开始.
```

EX:

| 0x23  | 0010 0011 |      |
| ----- | --------- | ---- |
| Index | TI        | RPL  |
| 00100 | 0         | 11   |
| 0x2B  | 0010 1011 |      |
| Index | TI        | RPL  |
| 00101 | 0         | 11   |
| 0x30  | 0011 0000 |      |
| Index | TI        | RPL  |
| 00110 | 0         | 00   |
| 0x3B  | 0011 1011 |      |
| Index | TI        | RPL  |
| 00110 | 0         | 11   |
| 0x53  | 0101 0011 |      |
| Index | TI        | RPL  |
| 01010 | 0         | 11   |

------

段描述符:

32位,定义了该段的属性.

![image-20230326203632589](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230326203632589.png)

```
P->G->S->TYPE.

P(段限制):
定义了该段描述符是否有效.
1	有效.
0	无效.

G(粒度):
定义了Segment Limit的单位
0	byte,最大为0x000FFFFF,1MB.
1	4kb,最大为0xFFFFFFFF,4GB.

S(描述符类型):
0	system.
1	code或者data.

TYPE(段类型):
和S有关,此处略.
```

TYPE:

S = 1:

![image-20230326210024318](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230326210024318.png)

```
Data:
    A(accessed):
    访问位.
    W(Write):
    可写位.
    E(expand-down):
    拓展位.
```

向上拓展和向下拓展,红色为段空间,即向上拓展和向下拓展互为补集,全集的大小和D/B有关(16/32位寻址方式).

![image-20230326210514299](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230326210514299.png)

```
Code:
    A(accessed):
    访问位.
    R(Read):
    可读位.
    C(conforming):
    一致位,此处略.
```

S = 0:

![image-20230326210109852](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230326210109852.png)

EX:

```
kd> dq 8003f000 l10
ReadVirtual: 8003f000 not properly sign extended
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 00000000`00000000
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff

段选择子为0x23,00100 0 11,索引为4,00cff300`0000ffff.P位所在的f大于等于8,即P位为1,该段描述符有效,G位为1,S位为1,是code/data段,TYPE为3,Data段,权限为:Read/Write,accessed.
Base:00000000
Atrribute:cff3
Limit:0xffffffff

段选择子为0x2B,00101 01 1,索引为5,80008b04`200020ab.P位所在的8等于大于8,即P位为1,该段描述符有效,G位为0,S位为0,是system段,TYPE为11,权限为:32-Bit TSS(Busy).
Base:80042000
Atrribute:008b
Limit:0x0ffff000

段选择子为0x30,00110 0 00,索引为6,ffc093df`f0000001.P位所在的9等于大于8,即P位为1,该段描述符有效,G位为1,S位为1,是code/data段,TYPE为3,Data段,权限为:Read/Write,accessed.
Base:ffdff000
Atrribute:c093
Limit:0x00001fff

段选择子为0x3B,00111 0 11,索引为7,0040f300`00000fff.P位所在的f等于大于8,即P位为1,该段描述符有效,G位为0,S位为1,是code/data段,TYPE为3,Data段,权限为:Read/Write,accessed.
Base:00000000
Atrribute:40f3
Limit:0x00000fff

段选择子为0x53,01010 0 11,索引为10,80008955`27000068.P位所在的8等于大于8,即P位为1,该段描述符有效,G位为0,S位为0,是system段,TYPE为9,权限为:Available.
Base:80552700
Atrribute:0089
Limit:0x00000068
```

------

段权限检查:

GPL(Global Privilege Level):
全局特权级别,GDT表里面的段描述符

CPL(Current Privilege Level):
当前特权级别,当前CS段选择子后2位

RPL(Requested Privilege Level):
请求特权级别,要使用的段选择子后2位

```
数据段的权限检查：
CPL <= DPL 并且 RPL <= DPL (数值上的比较)

kd> dq 8003f000
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 7f40f3fd`f0000fff
8003f040  0000f200`0400ffff 00000000`00000000
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff

mov ax,0xB
mov es,eax	//1011->1 0 11->00cf9b00`0000ffff,dpl为0,所以执行后权限检查不通过,就会触发异常,跳转到ntdll
```

------

代码跨段:

本质就是修改CS段寄存器,和EIP一样,涉及到代码的寄存器都无法通过指令直接改变.修改EIP可以使用jcc,call,ret等指令,CS段寄存器也一样,只不过是长跳转,jcc far,call far,retf等.

```
jmp 0x20:0x004183d7	//段选择子:偏移,即EIP(base通常为0).

1.段选择子拆分:
0x20->00100 0 00
2.GDT表拿到段描述符:
四种情况可以跳转:代码段,调用门,TSS任务段,任务门.这里只实验代码段.
3.权限检查:
非一致代码段:CPL == DPL && RPL <= DPL
一致代码段:CPL >= DPL
4.加载段描述符:
将段描述符加载到CS
5.代码执行:
EIP:CS.base + offset.
然后执行CS:EIP

一致位(conforming):
S为1,TYPE大于等于12,就为一致性代码段.

总结：
对于一致代码段:也就是共享的段
	特权级高的程序不允许访问特权级低的数据:核心态不允许访问用户态的数据
	特权级低的程序可以访问到特权级高的数据,但特权级不会改变:用户态还是用户态

对于普通代码段:也就是非一致代码段
	只允许同级访问
	绝对禁止不同级别的访问:核心态不是用户态,用户态也不是核心态.

直接对代码段进行JMP或者CALL的操作,无论目标是一致代码段还是非一致代码段,CPL都不会发生改变.如果要提升CPL的权限,只能通过调用门.
```

```
kd> dq 8003f000
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 7f40f3fd`f0000fff
8003f040  0000f200`0400ffff 00000000`00000000
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff
```

00cffb00`0000ffff为非一致代码段,CPL(3) == DPL(3) && RPL <= DPL(3),构造段选择子,0x11011. 

```
jmp far 001b:004183fd	//OK
jmp far 0008:004183fd	//ERROR
```

8003f048:00cfff00`0000ffff为一致代码段,CPL(3) >= DPL(0)

```
kd> eq 8003f048 00cfff00`0000ffff
WriteVirtual: 8003f048 not properly sign extended
kd> dq 8003f000
ReadVirtual: 8003f000 not properly sign extended
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 00cfff00`0000ffff
8003f050  00000000`0000ffff 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff

jmp far 004b:004183fd	//OK
```

![image-20230327213902570](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230327213902570.png)

------

长调用堆栈图:

指令格式：CALL  CS:EIP(EIP是废弃的)

1.跨段不提权:CPL权限并不发生改变,所以堆栈不变.

![image-20230329092803222](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230329092803222.png)

2.跨段并提权:CPL会改变,所以堆栈的特权级别也改变.

![image-20230329093028707](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230329093028707.png)

------

EX:

```c
#include "stdafx.h"
#include <windows.h>

void __declspec(naked) GetRegister()
{
	__asm
	{
		int 3

		retf
	}
}



int main(int argc, char* argv[])
{
	char buff[6];
	*(DWORD*)&buff[0] = 0x12345678;
	*(WORD*)&buff[4] = 0x48;
	__asm
	{
		call fword ptr[buff]
	}

	getchar();

	return 0;
}
```

![image-20230329103049437](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230329103049437.png)

![image-20230329103219542](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230329103219542.png)

```c
#include "stdafx.h"
#include <windows.h>

BYTE GDT[6] = {0};
DWORD dwH2GValue;

void __declspec(naked) GetRegister()
{
	__asm
	{
		pushad
		pushfd

		mov eax,0x8003f000
		mov ebx,[eax]
		mov dwH2GValue,ebx
		sgdt GDT

		popfd
		popad
		retf
	}
}

void PrintRegister()
{
	DWORD GDT_ADDR = *(PDWORD)(&GDT[2]);
	WORD GDT_LIMIT = *(PWORD)(&GDT[0]);

	printf("%x %x %x\n", dwH2GValue, GDT_ADDR, GDT_LIMIT);
}

int main(int argc, char* argv[])
{
	char buff[6];
	*(DWORD*)&buff[0] = 0x12345678;
	*(WORD*)&buff[4] = 0x48;
	__asm
	{
		call fword ptr[buff]
	}

	PrintRegister();
	getchar();

	return 0;
}
```

![image-20230329105047862](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230329105047862-1680058248632-1.png)

------

```c
#include "stdafx.h"
#include <windows.h>

DWORD x, y, z;

void __declspec(naked) GetRegister()
{
	__asm
	{
		pushad
		pushfd
		
		mov eax,[esp+0x24+0x8+0x8]	//0x24是pushad,pushfd进去的9个寄存器,0x8是EIP,CS.push进去的参数在中间,然后末尾是ESP,CS.
		mov dword ptr ds:[x],eax
		mov eax,[esp+0x24+0x8+0x4]
		mov dword ptr ds:[y],eax
		mov eax,[esp+0x24+0x8+0x0]
		mov dword ptr ds:[z],eax
		mov eax,0x0040db20
		mov dword ptr [esp+0x24],eax

		popfd
		popad
		retf 0xC
	}
}

void PrintRegister()
{
	printf("%x %x %x\n", x, y, z);
}

void print666()
{
	while(true)
	{
		Sleep(1000);
		printf("666");
	}
}

int main(int argc, char* argv[])
{
	char buff[6];
	*(DWORD*)&buff[0] = 0x12345678;
	*(WORD*)&buff[4] = 0x48;
	__asm
	{
		push 1
		push 2
		push 3
		call fword ptr[buff]
	}

	PrintRegister();
	getchar();

	return 0;
}
```

------

中断门:

```c
#include "stdafx.h"
#include <windows.h>

DWORD dwH2GValue;

void __declspec(naked) GetRegister()
{
	__asm
	{	
        int 3
		/*
		只能
        mov eax,0x12345678
        mov eax,[eax]
        不能直接
        mov eax,[0x12345678]  
		*/
		mov eax,0x8003f400		//mov eax,[0x8003f400]
		mov ebx,[eax]
		mov dwH2GValue,ebx

		iretd
	}
}

void PrintRegister()
{
	printf("%x \n", dwH2GValue);
}

int main(int argc, char* argv[])
{
	__asm
	{
		INT 0x20
	}

	PrintRegister();

	return 0;
}
```

![image-20230402150310592](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230402150310592.png)

 EIP->CS->EFL->ESP->SS

![img](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/1197364-20200712230227891-1208895313.png)

中断门和调用门的除了流程之外的区别是:

1.中断门的权限校验在IDT中,调用门在GDT.

2.中断门调用时堆栈会多保存EFL寄存器.

3.中断门不能传递参数.

------

陷阱门:

![image-20230402150745462](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230402150745462.png)

![img](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/1197364-20200719110036207-1537688390.png)

陷阱门与中断门唯一的不同就是ELF中的IF位,中断门执行后IF设置为0,陷阱门执行后IF不变.

------

任务状态段 TSS(Task State Segment):

同时改变很多寄存器的值.

![image-20230402192807473](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230402192807473.png)

TR寄存器:

LTR(Load TR):

用LTR指令去装载的话 仅仅是改变TR寄存器的值(96位) 并没有真正改变TSS 

LTR指令只能在系统层使用

加载后TSS段描述符会状态位会发生改变

STR(Save TR):

如果用STR去读的话，只读了TR的16位 也就是选择子

```c
// TSS.cpp : Defines the entry point for the console application.
//
 
#include <stdlib.h>
#include <stdio.h>
 
 
void __declspec(naked) EipFunction()
{
	__asm
	{
		int 3;   //便于内核调试器断下
		push ebp;
		mov ebp, esp;
 
		
	}
}
 
 
int main(int argc, char* argv[])
{
	char espBuffer[0x30] = { 0 }; //开辟空间构建TSS内存的栈顶
	printf("Please Input Cr3 Value \r\n");
	unsigned int Cr3Value = 0;
	scanf("%d", &Cr3Value);
	//构建TSS的内存
	unsigned int TssMemory[0x64] = {
	0x00000000,// Previous TaskLink 操作系统会给写入
	0x00000000,// esp 0
	0x00000000,// ss  0
	0x00000000,// esp 1
	0x00000000,// ss  1
	0x00000000,// esp 2
	0x00000000,// ss  2
	(unsigned int)Cr3Value,
	(unsigned int)EipFunction,// EIP              执行你函数的地址.EIP指向.这样才可以执行你的函数
	0x00000000,// eflags 
	0x12345678,// eax
	0x87654321,// ecx
	0x11223344,// edx
	0x44332211,// ebx              寄存器随便给.便于调试的时候更直观的看到
	(unsigned int)espBuffer,	// esp              栈顶的值.需要我们指定
	0x00000000,// ebp              栈底的值
	0x00000000,// esi
	0x00000000,// edi
	0x00000023,// es				段寄存器我们也要给 如果切换到内核则按照内核中的给.
	0x00000008,// cs				0环的代码段选择子. 如果想要切换rign3就给ring3的. 可以windbg调试
	0x00000010,// ss                同cs一样.ss与cs必须在同一代码段下
	0x00000023,// ds
	0x00000030,// fs
	0x00000000,// gs
	0x00000000,// LDT
	0x20ac0000,// Io              这个根据Windbg调试得出来.看一下填写即可.
	};
 
	printf("TSS内存的地址为 : %p \r\n", TssMemory);     //输出一下TSS内存的地址. 便于构造段描述符.
	fflush(stdin);
    getchar();
	char FarAddress[6] = { 0 };//构造我们的远call 指令.同调用门一样
	//call far 段选择子:eip 
	*(unsigned int*)&FarAddress[0] = 0x00000000; //EIP在远call的时候不用.随便给.
	*(unsigned short*)&FarAddress[4] = 0x48;    //构造的TSS段在GDT表中的段选择子.
	__asm
	{
		call fword ptr[FarAddress];
	}
	printf("over _ \r\n");
	system("pause");
	return 0;
}
```

需要TSS表在连续的页上,有点靠运气,我蓝屏好几次都没成功.

------

页:

10-10-12

ntoskrnl.exe:MmIsAddressValid

```c
BOOLEAN __stdcall MmIsAddressValid(PVOID VirtualAddress)
{
  int v1; // eax
  _DWORD *v2; // eax
  BOOLEAN result; // al

  v1 = *(_DWORD *)((((unsigned int)VirtualAddress >> 20) & 0xFFC) - 1070596096);
  result = 0;
  if ( (v1 & 1) != 0 )
  {
    if ( (v1 & 0x80u) != 0 )
      return 1;
    v2 = (_DWORD *)((((unsigned int)VirtualAddress >> 10) & 0x3FFFFC) - 0x40000000);
    if ( (*v2 & 1) != 0
      && ((*v2 & 0x80u) == 0 || (*(_DWORD *)((((unsigned int)VirtualAddress >> 10) & 0xFFC) - 1070596096) & 0x81) != 0x81) )
    {
      return 1;
    }
  }
  return result;
}
```

```assembly
.text:0040AEC6 8B FF                         mov     edi, edi
.text:0040AEC8 55                            push    ebp
.text:0040AEC9 8B EC                         mov     ebp, esp
.text:0040AECB 8B 4D 08                      mov     ecx, [ebp+VirtualAddress]	#设线性地址为0x00428C50
.text:0040AECE 8B C1                         mov     eax, ecx		#eax=0x00428C50
.text:0040AED0 C1 E8 14                      shr     eax, 14h		#右移0x14,20位,为什么不是右移10+12位呢,后面有个巧妙的办法,eax=0000 0000 0100
.text:0040AED3 BA FC 0F 00 00                mov     edx, 0FFCh		#edx=0000 1111 1111 1100
.text:0040AED8 23 C2                         and     eax, edx		#这里很巧妙,直接将eax后2位清空,然后现在eax的值就是第一个10位(DPI)*4后的结果,即PDE
.text:0040AEDA 2D 00 00 D0 3F                sub     eax, 3FD00000h	#PDE-3FD00000h=PDE+C0300000,现在将eax里面的线性地址就是PDE对应的物理地址
.text:0040AEDF 8B 00                         mov     eax, [eax]		#取PDE的值
.text:0040AEE1 A8 01                         test    al, 1			#逻辑与,检查P位是否为1,有效位
.text:0040AEE3 0F 84 BC 2E 01 00             jz      loc_41DDA5		
.text:0040AEE3
.text:0040AEE9 84 C0                         test    al, al			#判断al是否为0?但之前不已经P位为1了吗,看别人注释是为了判断PS位,大页,这里不太懂
.text:0040AEEB 78 24                         js      short loc_40AF11	
.text:0040AEEB
.text:0040AEED C1 E9 0A                      shr     ecx, 0Ah		#ecx=0x00428C50,右移0xA,10位,ecx=10A3(0000 0000 01,00 0010 1000 11)
.text:0040AEF0 81 E1 FC FF 3F 00             and     ecx, 3FFFFCh	#ecx=10A0,擦,这里为什么是3FFFFC,而不是FFFFFC?
.text:0040AEF6 81 E9 00 00 00 40             sub     ecx, 40000000h	#...没想通,反正现在ecx里面的线性地址就是PTE对应的物理地址
.text:0040AEFC 8B C1                         mov     eax, ecx	
.text:0040AEFE 8B 08                         mov     ecx, [eax]		#取出PTE
.text:0040AF00 F6 C1 01                      test    cl, 1			#判断PTE,P位
.text:0040AF03 0F 84 9C 2E 01 00             jz      loc_41DDA5
.text:0040AF03
.text:0040AF09 84 C9                         test    cl, cl			#判断PAT位
.text:0040AF0B 0F 88 3F 42 04 00             js      loc_44F150
.text:0040AF0B
.text:0040AF11
.text:0040AF11                               loc_40AF11:                             ; CODE XREF: MmIsAddressValid(x)+25↑j
.text:0040AF11                                                                       ; MmIsAddressValid(x)+44298↓j
.text:0040AF11 B0 01                         mov     al, 1
.text:0040AF11
.text:0040AF13
.text:0040AF13                               loc_40AF13:                             ; CODE XREF: MmIsAddressValid(x)+12EE1↓j
.text:0040AF13 5D                            pop     ebp
.text:0040AF14 C2 04 00                      retn    4
```

------

2-9-9-12

ntkrnlpa.exe:MmIsAddressValid

```c
BOOLEAN __stdcall MmIsAddressValid(PVOID VirtualAddress)
{
  int v1; // edx
  _DWORD *v2; // ecx
  BOOLEAN result; // al

  v1 = *(_DWORD *)((((unsigned int)VirtualAddress >> 18) & 0x3FF8) - 1067450368);
  result = 0;
  if ( (v1 & 1) != 0 )
  {
    if ( (v1 & 0x80) != 0 )
      return 1;
    v2 = (_DWORD *)((((unsigned int)VirtualAddress >> 9) & 0x7FFFF8) - 0x40000000);
    if ( (*v2 & 1) != 0
      && ((*v2 & 0x80) == 0 || (*(_DWORD *)((((unsigned int)VirtualAddress >> 9) & 0x3FF8) - 1067450368) & 0x81) != 129) )
    {
      return 1;
    }
  }
  return result;
}
```

chatgpt:

```c
// 判断虚拟地址是否有效
// 返回值为 BOOLEAN 类型，表示是否有效
BOOLEAN IsVirtualAddressValid(PVOID VirtualAddress)
{
  // 计算目标地址所在的页表项
  int PageDirectoryEntry = *(_DWORD *)((((unsigned int)VirtualAddress >> 18) & 0x3FF8) - 0x3FA00000);
  BOOLEAN result = 0;

  // 如果页表项标志为存在
  if ( (PageDirectoryEntry & 1) != 0 )
  {
    // 如果页表项标志为用户态访问或全局页
    if ( (PageDirectoryEntry & 0x80) != 0 )
      return 1;

    // 计算目标地址所在的页表项
    _DWORD *PageTableEntry = (_DWORD *)((((unsigned int)VirtualAddress >> 9) & 0x7FFFF8) - 0x40000000);
    
    // 如果页表项标志为存在
    if ( (*PageTableEntry & 1) != 0
      // 如果页表项标志为用户态访问或全局页，或者页表项标志为内核态访问，但 CR3 控制寄存器的高位为 1
      && ((*PageTableEntry & 0x80) == 0 || (*(_DWORD *)((((unsigned int)VirtualAddress >> 9) & 0x3FF8) - 0x3FA00000) & 0x81) != 0x81) )
    {
      // 返回地址有效
      return 1;
    }
  }

  // 返回地址无效
  return result;
}
```

------

```c
#include "stdafx.h"
#include <windows.h>

DWORD TempFnAddress;

void __declspec(naked) Proc()
{
	__asm
	{
		//1.给0地址挂物理页	0x01234867(G=0)	0x01234967(G=1)
		mov dword ptr ds:[0xC0000000],0x01234867
		//2.给0地址赋值
		mov dword ptr ds:[0],0x66666666

		INVLPG dword ptr ds:[0]	//删除0地址的tls
		mov eax,cr3
		mov cr3,eax	//刷新cr3

		//3.改变物理页
		mov dword ptr ds:[0xC0000000],0x02345679

		//4.再次读取线性地址
		mov eax,dword ptr ds:[0]
		mov TempFnAddress,eax

		retf
	}
}

int main(int argc, char* argv[])
{
	char buff[6] = {0};
	
	*(DWORD*)&buff[4] = 0x48;	//01001 0 00 -> 9

	__asm
	{
		call fword ptr[buff]
	}
	
	printf("%x\n", TempFnAddress);

	return 0;
}


```

```
kd> dq 8003f000
ReadVirtual: 8003f000 not properly sign extended
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 00000000`00000000
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff

eq 8003f048 0040EC00`0008D865
0x0012fec0

1111 0010 EC

//在8003f048 位置构造一个3环进0环的调用门,偏移先用0代替


 EAX = 00000000 EBX = 7FFD8000
 ECX = 00000000 EDX = 00380E28
 ESI = 00000000 EDI = 0012FF80
 EIP = 0040104A ESP = 0012FEC0
 EBP = 0012FF80 EFL = 00000246

```

------

```c
#include "stdafx.h"
#include <windows.h>

DWORD dwAddrTmp;
DWORD PDI;
DWORD PTI;
DWORD Offset;

bool ReadMemory(OUT BYTE* buffer,IN DWORD dwAddr,IN DWORD dwLeght)
{
	dwAddrTmp = dwAddr;
	PDI = dwAddrTmp >> 22;
	dwAddrTmp = dwAddr;
	PTI = (dwAddrTmp >> 12) & 0x3FF;
	dwAddrTmp = dwAddr;
	Offset = dwAddrTmp & 0xFFF;
	
	printf("PDI:%x,PTI:%x,Offset:%x.\n", PDI, PTI, Offset);
	
	//DWORD PTE = 0xC0000000 + PDI * 0x4000 + PTI;

	//printf("PTE:%x", *(DWORD*)PTE);


	return false;
}

int main(int argc, char* argv[])
{
	BYTE buffTmp[6] = {0};
	BYTE buffer[100] = {0};
	DWORD dwAddr = 0x00401234;
	DWORD dwLeght = 4;
	
	//printf("%s", (BYTE*)dwAddr);
	
	
	*(DWORD*)&buffTmp[4] = 0x48;	//01001 0 00 -> 9
	__asm
	{
		push dwLeght
		push dwAddr
		push buffer

		call fword ptr[buffTmp]
	}

	/*
	bool x = ReadMemory(buffer,dwAddr,dwLeght);
	if(x = true)
	{
		printf("%x:%s.\n", dwAddr, buffer);
	}else
	{
		printf("ReadMemory error!\n");
	}
	*/

	return 0;
}
```

```c
#include "stdafx.h"
#include <windows.h>

int main(int argc, char* argv[])
{
	BYTE buffTmp[6] = {0};
	
	*(DWORD*)&buffTmp[4] = 0x48;	//01001 0 00 -> 9

	__asm
	{
		int 3	//eq 8003f048 0040EC00`0008D865
		call fword ptr[buffTmp]	//下一条指令的地址:0040D865
		mov esp,[esp+0x8]	//由于使用调用门之后会根据TSS重新分配ESP，所以需要回到之前的esp，现在cs，ss都是ring0.
	}
	
	DWORD dwAddr = 0x00400000;
	DWORD dwLeght = 4;

	DWORD dwAddrTmp = dwAddr;
	DWORD PDI = dwAddrTmp >> 22;
	dwAddrTmp = dwAddr;
	DWORD PTI = (dwAddrTmp >> 12) & 0x3FF;
	dwAddrTmp = dwAddr;
	DWORD Offset = dwAddrTmp & 0xFFF;
	
	printf("PDI:%x,PTI:%x,Offset:%x.\n", PDI, PTI, Offset);
	printf("%x\n", *(DWORD*)0xC0004000);

	return 0;
}

```

## 2.驱动

```c
#include <ntifs.h> //这个头文件内包含了大量驱动相关的头文件，一次性包含，省时省力。
```

```c
#include "ntddk.h"
 
void UnloadDriver(PDRIVER_OBJECT driver);
 
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) {
	DbgBreakPoint();
    DbgPrint("-------%wZ--------",RegistryPath);
    DbgPrint("驱动加载了。\r\n");    //驱动的打印函数，相当于3环的printf
	DbgPrint("DriverObject:%p。\r\n", DriverObject);
    DriverObject->DriverUnload = UnloadDriver;    //为驱动指定卸载函数
    return STATUS_SUCCESS;
}
//驱动卸载函数
void UnloadDriver(PDRIVER_OBJECT driver) {
    DbgPrint("驱动停止了。\r\n");
}
```

```
kd> dt _DRIVER_OBJECT 0x8A22ED18
nt!_DRIVER_OBJECT
   +0x000 Type             : 0n4
   +0x002 Size             : 0n168
   +0x004 DeviceObject     : (null) 
   +0x008 Flags            : 0x12
   +0x00c DriverStart      : 0xba428000 Void
   +0x010 DriverSize       : 0x6000
   +0x014 DriverSection    : 0x8a13a9d8 Void
   +0x018 DriverExtension  : 0x8a22edc0 _DRIVER_EXTENSION
   +0x01c DriverName       : _UNICODE_STRING "\Driver\驱动"
   +0x024 HardwareDatabase : 0x8067f260 _UNICODE_STRING "\REGISTRY\MACHINE\HARDWARE\DESCRIPTION\SYSTEM"
   +0x028 FastIoDispatch   : (null) 
   +0x02c DriverInit       : 0xba429000     long  _empty_!DriverEntry+0
   +0x030 DriverStartIo    : (null) 
   +0x034 DriverUnload     : 0xba429050     void  _empty_!UnloadDriver+0
   +0x038 MajorFunction    : [28] 0x804f55ce     long  nt!IopInvalidDeviceRequest+0
kd> dd 0xba428000
ReadVirtual: ba428000 not properly sign extended
ba428000  00905a4d 00000003 00000004 0000ffff
ba428010  000000b8 00000000 00000040 00000000
ba428020  00000000 00000000 00000000 00000000
ba428030  00000000 00000000 00000000 000000c0
ba428040  0eba1f0e cd09b400 4c01b821 685421cd
ba428050  70207369 72676f72 63206d61 6f6e6e61
ba428060  65622074 6e757220 206e6920 20534f44
ba428070  65646f6d 0a0d0d2e 00000024 00000000
kd> dt _DRIVER_EXTENSION 0x8a22edc0
nt!_DRIVER_EXTENSION
   +0x000 DriverObject     : 0x8a22ed18 _DRIVER_OBJECT
   +0x004 AddDevice        : (null) 
   +0x008 Count            : 0
   +0x00c ServiceKeyName   : _UNICODE_STRING "驱动"
   +0x014 ClientDriverExtension : (null) 
   +0x018 FsFilterCallbacks : (null) 
```

```
dt _LDR_DATA_TABLE_ENTRY 0x8a13a9d8
```

打印所有模块

```c
#include <ntifs.h>
 
void UnloadDriver(PDRIVER_OBJECT driver);

typedef struct _LDR_DATA_TABLE_ENTRY {
    LIST_ENTRY InLoadOrderLinks;
    ULONG __Undefined1;
    ULONG __Undefined2;
    ULONG __Undefined3;
    ULONG NonPagedDebugInfo;
    ULONG DllBase;
    ULONG EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT __Undefined5;
    ULONG  __Undefined6;
    ULONG  CheckSum;
    ULONG  TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) {
    PLDR_DATA_TABLE_ENTRY selfNode = (PLDR_DATA_TABLE_ENTRY)DriverObject->DriverSection;
    PLDR_DATA_TABLE_ENTRY preNode = selfNode;
    UINT32 index = 1;
    do {
        DbgPrint("[db] %d  driver name = %wZ \r\n", index++,&preNode->BaseDllName);
        preNode = (PLDR_DATA_TABLE_ENTRY)preNode->InLoadOrderLinks.Flink;
    } while (preNode != selfNode);
    DriverObject->DriverUnload = UnloadDriver;
    return STATUS_SUCCESS;
}
//驱动卸载函数
void UnloadDriver(PDRIVER_OBJECT driver) {
    DbgPrint("驱动停止了。\r\n");
}
```

kill360主动防御

```c
#include <ntifs.h>

void UnloadDriver(PDRIVER_OBJECT driver);

typedef struct _LDR_DATA_TABLE_ENTRY {
    LIST_ENTRY InLoadOrderLinks;
    ULONG __Undefined1;
    ULONG __Undefined2;
    ULONG __Undefined3;
    ULONG NonPagedDebugInfo;
    ULONG DllBase;
    ULONG EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT __Undefined5;
    ULONG  __Undefined6;
    ULONG  CheckSum;
    ULONG  TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) {
    PLDR_DATA_TABLE_ENTRY selfNode = (PLDR_DATA_TABLE_ENTRY)DriverObject->DriverSection;
    PLDR_DATA_TABLE_ENTRY preNode = selfNode;

    UNICODE_STRING kernelName = { 0 };
    RtlInitUnicodeString(&kernelName, L"ntoskrnl.exe");

    do {
        if (preNode->BaseDllName.Length != 0 && RtlCompareUnicodeString(&preNode->BaseDllName, &kernelName, TRUE) == 0) {
            DbgPrint("已找到:%wZ\r\n", &preNode->BaseDllName);   
            break;
        }
        preNode = (PLDR_DATA_TABLE_ENTRY)preNode->InLoadOrderLinks.Flink;
    } while (preNode != selfNode);

    ULONG KernelBase = preNode->DllBase;
    ULONG KernelLimit = preNode->SizeOfImage;
	//特征码
    ULONG str1 = 0x3b08758b;
    ULONG str2 = 0x0248be8d;
    ULONG str3 = 0x0174868d;

    typedef NTSTATUS(*funcPspTerminateProcess)(PEPROCESS process, NTSTATUS ExitStatus);
    funcPspTerminateProcess PspTerminateProcess;

    for (ULONG i = KernelBase; i < KernelBase + KernelLimit; i++)
    {
        if (*(PULONG)i == str1)
        {
            if (*(PULONG)(i + 0x10) == str2)
            {
                if (*(PULONG)(i + 0x1c) == str3)
                {
                    PspTerminateProcess = (funcPspTerminateProcess)(i - 0xc);
                    break;
                }
            }
        }

    }

	DbgPrint("%p\r\n", PspTerminateProcess);
	
    PEPROCESS pEprocesszz = NULL;
    NTSTATUS status = PsLookupProcessByProcessId((HANDLE)956, &pEprocesszz);
    if (status != STATUS_SUCCESS) {
        DbgPrint(TEXT("获取进程的PEPROCESS失败\n"));
        return status;
    }

    status = PspTerminateProcess(pEprocesszz, 0);
    if (status != STATUS_SUCCESS)
    {
        DbgPrint(TEXT("杀死进程失败\n"));
    }
    DbgPrint(TEXT("杀死进程成功\n"));
	
	DriverObject->DriverUnload = UnloadDriver;
    return STATUS_SUCCESS;
}
//驱动卸载函数
void UnloadDriver(PDRIVER_OBJECT driver) {
    DbgPrint("驱动停止了。\r\n");
}
```

<video src="./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/2023-04-07%2016-45-40.mkv"></video>

设备读写

ring0:

```c
#include <ntddk.h>

//设备名,0环用
#define DEVICE_NAME L"\\Device\\DayuDev"
//符号链接名,3环用
#define SYMBOLICLINK_NAME L"\\??\\DayuDevLnk"

#define OPER1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define OPER2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)

//函数声明
NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING RegPath);
VOID DriverUnload(PDRIVER_OBJECT pDriver);
NTSTATUS IrpCreateProc(PDEVICE_OBJECT pDevObj, PIRP pIrp);
NTSTATUS IrpCloseProc(PDEVICE_OBJECT pDevObj, PIRP pIrp);
NTSTATUS IrpDeviceControlProc(PDEVICE_OBJECT pDevObj, PIRP pIrp);

NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING RegPath)
{
	NTSTATUS status;
	ULONG uIndex = 0;
	PDEVICE_OBJECT pDeviceObj = NULL;

	UNICODE_STRING DeviceName;	//设备名,0环用
	UNICODE_STRING SymbolicLinkName;	//符号链接名,3环用

	//创建设备名称
	RtlInitUnicodeString(&DeviceName, DEVICE_NAME);
	//创建设备
	status = IoCreateDevice(pDriver, 0, &DeviceName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &pDeviceObj);
	if (status != STATUS_SUCCESS)
	{
		IoDeleteDevice(pDeviceObj);
		DbgPrint("设备创建失败.\n");
		return status;
	}
	DbgPrint("创建设备成功.\n");
	//设置交互数据的方式
	pDeviceObj->Flags |= DO_BUFFERED_IO;
	//创建符号链接
	RtlInitUnicodeString(&SymbolicLinkName, SYMBOLICLINK_NAME);
	IoCreateSymbolicLink(&SymbolicLinkName, &DeviceName);
	//设置分发函数
	pDriver->MajorFunction[IRP_MJ_CREATE] = IrpCreateProc;
	pDriver->MajorFunction[IRP_MJ_CLOSE] = IrpCloseProc;
	pDriver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IrpDeviceControlProc;
	//设置卸载函数
	pDriver->DriverUnload = DriverUnload;
	return STATUS_SUCCESS;

}

//卸载驱动
VOID DriverUnload(PDRIVER_OBJECT pDriver)
{
	UNICODE_STRING SymbolicLinkName;
	RtlInitUnicodeString(&SymbolicLinkName, SYMBOLICLINK_NAME);
	IoDeleteSymbolicLink(&SymbolicLinkName);
	IoDeleteDevice(pDriver->DeviceObject);
	DbgPrint("驱动卸载成功\n");
}

NTSTATUS IrpCreateProc(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
	DbgPrint("应用层连接设备.\n");

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	pIrp->IoStatus.Information = 0;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

	return STATUS_SUCCESS;
}

NTSTATUS IrpCloseProc(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
	DbgPrint("应用层断开连接设备.\n");

	pIrp->IoStatus.Status = STATUS_SUCCESS;
	pIrp->IoStatus.Information = 0;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

NTSTATUS IrpDeviceControlProc(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
	DbgPrint("应用层:IrpDeviceControlProc.\n");
	NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;
	PIO_STACK_LOCATION pIrpStak;
	ULONG uIoControlCode;
	PVOID pIoBuffer;
	ULONG uInLength;
	ULONG uOutLength;
	ULONG uRead;
	ULONG uWrite;

	uRead = 0;
	uWrite = 0x12345678;
	//获取IRP数据
	pIrpStak = IoGetCurrentIrpStackLocation(pIrp);
	//获取控制码
	uIoControlCode = pIrpStak->Parameters.DeviceIoControl.IoControlCode;
	//获取缓冲区地址(输入输出是同一个)
	pIoBuffer = pIrp->AssociatedIrp.SystemBuffer;
	//Ring3发送数据的长度
	uInLength = pIrpStak->Parameters.DeviceIoControl.InputBufferLength;
	//Ring0发送数据的长度
	uOutLength = pIrpStak->Parameters.DeviceIoControl.OutputBufferLength;

	switch (uIoControlCode)
	{
	case OPER1:
		{
			DbgPrint("IrpDeviceControlProc -> OPER1...\n");
			pIrp->IoStatus.Information = 0;
			status = STATUS_SUCCESS;
			break;
		}
	case OPER2:
		{
			DbgPrint("IrpDeviceControlProc -> OPER2 输入字节数: %d\n", uInLength);
			DbgPrint("IrpDeviceControlProc -> OPER2 输出字节数: %d\n", uOutLength);
			//读取缓冲区
			memcpy(&uRead, pIoBuffer, 4);
			DbgPrint("IrpDeviceControlProc -> OPER2 uRead: %x\n", uRead);
			//写入缓冲区
			memcpy(pIoBuffer, &uWrite, 4);
			//设置状态
			pIrp->IoStatus.Information = 4;	//返回两字节
			status = STATUS_SUCCESS;
			break;

		}
	}

	pIrp->IoStatus.Status = status;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}
```

ring3:

```c
// test.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <stdio.h>
#include <Windows.h>
#include <winioctl.h>
#define SYMBOLICLINK_NAME L"\\\\.\\DayuDevLnk"
#define OPER1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define OPER2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IN_BUFFER_MAXLENGTH 4
#define OUT_BUFFER_MAXLENGTH 4

int main(int argc, char* argv[])
{
	HANDLE hDevice = CreateFileW(SYMBOLICLINK_NAME, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, 0);
	DWORD dwError = GetLastError();
	if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("获取设备句柄失败 %d.\n", dwError); // 如果返回1，请在驱动中指定 IRP_MJ_CREATE 处理函数
        getchar();
        return 1;
    }
    else
    {
        printf("获取设备句柄成功.\n");
    }

	// 测试通信
    DWORD dwInBuffer = 0x11111111;
    DWORD dwOutBuffer = 0xFFFFFFFF;
    DWORD dwOut;

	DeviceIoControl(hDevice, OPER2, &dwInBuffer, IN_BUFFER_MAXLENGTH, &dwOutBuffer, OUT_BUFFER_MAXLENGTH, &dwOut, NULL);
	printf("dwOutBuffer: %08X dwOut: %08X\n", dwOutBuffer, dwOut);
	CloseHandle(hDevice);
	getchar();

	return 0;
}
```

![image-20230407203335194](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230407203335194.png)

ring3 Inline hook

```c
// test.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <stdio.h>
#include <windows.h>

DWORD Argtmp = 0;
BYTE* ProcAddr = 0;    // 原函数地址
DWORD OldProtect = 0;  // 保存旧的内存保护
BYTE OldCmd[20] = { 0 }; // 存储原函数头部原始指令 在最后面构造返回到原函数的指令

BYTE* HookProcAddr = 0; // 钩子函数的地址

// 函数指针 将数据作为指令执行
typedef void (*POLDCMD)();
POLDCMD pOldCmd = (POLDCMD)(char*)OldCmd;
// printf的格式
//char* format = "%x";

DWORD add(DWORD a, DWORD b)
{
    return a + b;
}

void __declspec(naked) HookProc()
{
    // 保存现场
    /*
    0012FF00   00000246 //pushfd
    0012FF04   0012FF80
    0012FF08   0012B750
    0012FF0C   0012FF80
    0012FF10   0012FF24
    0012FF14   7FFDE000
    0012FF18   00401020  test.add
    0012FF1C   0000002B
    0012FF20   00401020  test.add   //pushad
    */
    // 保存现场
    __asm
    {
        pushad
        pushfd

        mov eax, esp
        add eax, 40
        mov eax, [eax]
        mov dword ptr ds : Argtmp, eax
    }

    // 获得参数1
    printf("a = %x\n", Argtmp);

    // 获得参数2
    __asm
    {
        mov eax, esp
        add eax, 44
        mov eax, [eax]
        mov dword ptr ds : Argtmp, eax
    }

    printf("b = %x\n", Argtmp);

    // 还原现场
    __asm
    {

        popfd
        popad

        // 执行原函数头部指令 并返回到原函数下一行继续执行
        jmp pOldCmd
    }
}

void InlineHook()
{   
    /*
    20:   DWORD add(DWORD a, DWORD b)
    21:   {
    00401020 55                   push        ebp
    00401021 8B EC                mov         ebp,esp
    00401023 83 EC 40             sub         esp,40h   //对齐指令,需要替换6个字节,jmp+地址是5个字节,然后再nop一个.
    00401026 53                   push        ebx
    00401027 56                   push        esi
    00401028 57                   push        edi
    00401029 8D 7D C0             lea         edi,[ebp-40h]
    0040102C B9 10 00 00 00       mov         ecx,10h
    00401031 B8 CC CC CC CC       mov         eax,0CCCCCCCCh
    00401036 F3 AB                rep stos    dword ptr [edi]
    22:       return a + b;
    00401038 8B 45 08             mov         eax,dword ptr [ebp+8]
    0040103B 03 45 0C             add         eax,dword ptr [ebp+0Ch]
    23:   }
    0040103E 5F                   pop         edi
    0040103F 5E                   pop         esi
    00401040 5B                   pop         ebx
    00401041 8B E5                mov         esp,ebp
    00401043 5D                   pop         ebp
    00401044 C3                   ret
    */
    // 获得需要挂钩的函数地址
    ProcAddr = (BYTE*)add + 1;  //00401005 E9 16 00 00 00       jmp         add (00401020)
    ProcAddr += *(DWORD*)ProcAddr + 4;  //00401020  DWORD add(DWORD a, DWORD b)
    // 修改内存保护
    VirtualProtect(ProcAddr, 6, PAGE_EXECUTE_READWRITE, &OldProtect);   //修改6个字节的保护属性,向上取整为4kb.
    // 将被覆盖的指令复制到数组中
    strncpy((char*)OldCmd, (char*)ProcAddr, 6); //保存指令

    // 数组末尾添上跳转指令 用于返回到被挂钩的函数
    OldCmd[6] = 0xE9;   //E9,jmp
    *(DWORD*)&OldCmd[7] = (DWORD)(ProcAddr + 6) - (DWORD)&OldCmd[6] - 5;    //跳转地址

    // 获得钩子函数的地址
    HookProcAddr = (BYTE*)HookProc + 1;
    HookProcAddr += *(DWORD*)HookProcAddr + 4;  //hook func addr
    // 修改原函数的头部 跳转到钩子函数
    ProcAddr[0] = 0xE9;
    *(DWORD*)&ProcAddr[1] = HookProcAddr - ProcAddr - 5;    //jmp hook func

    // 跳转指令只占五个字节 原函数头部三行指令占六个字节 因此将多余字节填充为nop
    ProcAddr[5] = 0x90; //nop
    /*
    20:   DWORD add(DWORD a, DWORD b)
    21:   {
    00401020 E9 2B 00 00 00       jmp         HookProc (00401050)
    00401025 90                   nop
    */
}

void UnInlineHook()
{
    // 判断函数是否被挂钩
    if (ProcAddr[0] == 0xE9)
    {
        strncpy((char*)ProcAddr, (char*)OldCmd, 6);
    }
}

int main()
{
    DWORD sum;

    // 挂钩
    InlineHook();

    sum = add(1, 2);
    printf("sum = %x\n", sum);

    // 脱钩
    // UnInlineHook();

    sum = add(3, 4);
    printf("sum = %x\n", sum);

    return 0;
}
```

ring0 Inline hook

```c
#include <ntddk.h>
#include <ntstatus.h>

PUCHAR pNtOpenProcess;
UCHAR  OldCmd[20] = { 0 };
//函数指针 用于将数据作为指令执行
typedef VOID(*POLDCMD)();
POLDCMD pOldCmd = (POLDCMD)(PUCHAR)OldCmd;

PCHAR format = "%x %x %x %x \r\n";

typedef NTSTATUS(*NTOPENPROCESS)(
	PHANDLE ProcessHandle,
	ACCESS_MASK DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes,
	PCLIENT_ID ClientId);

typedef struct _KSYSTEM_SERVICE_TABLE
{
	PULONG  ServiceTableBase;			// 服务函数地址表基址  
	PULONG  ServiceCounterTableBase;	// SSDT函数被调用的次数
	ULONG   NumberOfService;			// 服务函数的个数  
	PULONG   ParamTableBase;			// 服务函数参数表基址   
} KSYSTEM_SERVICE_TABLE, * PKSYSTEM_SERVICE_TABLE;

typedef struct _KSERVICE_TABLE_DESCRIPTOR
{
	KSYSTEM_SERVICE_TABLE   ntoskrnl;		// ntoskrnl.exe 的服务函数  
	KSYSTEM_SERVICE_TABLE   win32k;			// win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持)  
	KSYSTEM_SERVICE_TABLE   notUsed1;
	KSYSTEM_SERVICE_TABLE   notUsed2;
}KSERVICE_TABLE_DESCRIPTOR, * PKSERVICE_TABLE_DESCRIPTOR;

// KeServiceDescriptorTable 是 ntoskrnl.exe 所导出的全局变量 申明一下就可以直接使用了
extern PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;

VOID PageProtectOn()
{
	__asm {//开启内存保护
		mov  eax, cr0
		or eax, 10000h
		mov  cr0, eax
		sti
	}
}

VOID PageProtectOff()
{
	__asm {//关闭内存保护
		cli
		mov  eax, cr0
		and eax, not 10000h
		mov  cr0, eax
	}
}

VOID __declspec(naked) HookProc() {
	__asm
	{
		//保存现场
		pushad
		pushfd

		mov eax, esp
		add eax, 40		//eflags + 8个通用寄存器 + 返回地址
		add eax, 12		//定位到最后一个参数
		push[eax]		//ClientId
		push[eax - 0x4]	//ObjectAttributes
		push[eax - 0x8]	//DesiredAccess
		push[eax - 0xC]	//ProcessHandle
		push format
		call DbgPrint
		add esp, 20

		//还原现场
		popfd
		popad

		//调用原本的指令，然后返回到原函数
		jmp pOldCmd
	}
}

NTSTATUS InlineHook()
{
	NTSTATUS status;
	status = STATUS_SUCCESS;

	PageProtectOff();

	//保存原来的指令
	pNtOpenProcess = (PUCHAR)KeServiceDescriptorTable->ntoskrnl.ServiceTableBase[0x7A];
	/*
	PAGE:004A8956 68 C4 00 00 00                push    0C4h
	PAGE:004A895B 68 50 CC 41 00                push    offset stru_41CC50
	PAGE:004A8960 E8 8E 34 F6 FF                call    __SEH_prolog
	*/
	RtlMoveMemory(OldCmd, pNtOpenProcess, 5);	//刚好5个

	//构造回去的指令，用于返回到原函数
	OldCmd[5] = 0xE9;
	*(PULONG)&OldCmd[6] = ((ULONG)pNtOpenProcess + 5) - (ULONG)&OldCmd[5] - 5;

	//内核函数不存在中间人（call后通过jmp跳转），函数地址为实际地址
	pNtOpenProcess[0] = 0xE9;
	*(PULONG)&pNtOpenProcess[1] = (ULONG)HookProc - (ULONG)pNtOpenProcess - 5;

	PageProtectOn();

	return status;
}

NTSTATUS UnInlineHook()
{
	NTSTATUS status;
	status = STATUS_SUCCESS;

	if (pNtOpenProcess[0] == 0xE9)
	{
		PageProtectOff();
		RtlMoveMemory(pNtOpenProcess, OldCmd, 5);
		PageProtectOn();
	}

	return status;
}

//卸载函数
VOID DriverUnload(PDRIVER_OBJECT driver)
{
	//卸载驱动时脱钩
	UnInlineHook();

	DbgPrint("驱动程序已停止.\r\n");
}

//驱动程序入口函数，相当于控制台的main函数
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
	DbgPrint("驱动程序已运行.\r\n");
	//运行驱动时挂钩
	InlineHook();

	//设置一个卸载函数  便于退出
	DriverObject->DriverUnload = DriverUnload;

	return STATUS_SUCCESS;
}
```

重载内核(还没hook)

```c
/*
重载内核
1.申请内存,按内存对齐展开
2.根据重定位表修复全局变量
3.修复IAT表(修复导入表的说法不准确)
4.山寨系统服务表
5.狸猫换太子(Hook KiFastCallEntry)
*/
#include <ntifs.h>
#include <ntimage.h>

typedef struct _KSYSTEM_SERVICE_TABLE
{
	PULONG ServiceTableBase;			// 函数地址表
	PULONG ServiceCounterTableBase;		// SSDT 函数被调用的次数
	ULONG NumberOfService;				// 函数个数
	PULONG ParamTableBase;				// 函数参数表
} KSYSTEM_SERVICE_TABLE, * PKSYSTEM_SERVICE_TABLE;

__declspec(dllimport) KSYSTEM_SERVICE_TABLE KeServiceDescriptorTable;

ULONG OrigImage = 0x804D8000;
KSYSTEM_SERVICE_TABLE* pNewSSDT;
PVOID pVirtualPointerTmp;

void LoadKernel();
void FixBaseRelocationTable(PVOID pNewImage);
void MakeNewSSDT(PVOID pNewImage);
void UnloadDriver(PDRIVER_OBJECT driver);

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
	DbgPrint("驱动已加载.\n");
	DbgPrint("开始重载内核.\n");

	LoadKernel();

	DriverObject->DriverUnload = UnloadDriver;    //为驱动指定卸载函数
	return STATUS_SUCCESS;
}

void LoadKernel()
{
	//1.申请内存, 按内存对齐展开
	NTSTATUS status;
	UNICODE_STRING KernelPath;
	HANDLE hFile;
	OBJECT_ATTRIBUTES ObjAttr;
	IO_STATUS_BLOCK IoStatusBlock;
	LARGE_INTEGER FileOffset;
	IMAGE_DOS_HEADER ImageDosHeader;
	IMAGE_NT_HEADERS32 ImageNtHeader;
	PIMAGE_SECTION_HEADER pImageSectionHeader;
	PVOID pVirtualPointer;
	ULONG uLoop;
	ULONG SectionVirtualAddress;
	ULONG SectionSize;

	InitializeObjectAttributes(&ObjAttr, &KernelPath, OBJ_CASE_INSENSITIVE, NULL, NULL);

	RtlInitUnicodeString(&KernelPath, L"\\??\\C:\\WINDOWS\\system32\\ntoskrnl.exe");
	status = ZwCreateFile(&hFile, FILE_ALL_ACCESS, &ObjAttr, &IoStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN, FILE_NON_DIRECTORY_FILE, NULL, 0);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("打开内核文件<失败>.\n");
		DbgPrint("%x", status);
		ZwClose(hFile);
		return;
	}
	DbgPrint("打开内核文件<成功>.\n");

	FileOffset.QuadPart = 0;	//文件偏移量位0,dos.
	status = ZwReadFile(hFile, NULL, NULL, NULL, &IoStatusBlock, &ImageDosHeader, sizeof(IMAGE_DOS_HEADER), &FileOffset, 0);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("读取dosHeader<失败>.\n");
		DbgPrint("%x", status);
		ZwClose(hFile);
		return;
	}

	FileOffset.QuadPart += ImageDosHeader.e_lfanew;
	status = ZwReadFile(hFile, NULL, NULL, NULL, &IoStatusBlock, &ImageNtHeader, sizeof(IMAGE_NT_HEADERS32), &FileOffset, 0);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("读取ntHeader<失败>.\n");
		DbgPrint("%x", status);
		ZwClose(hFile);
		return;
	}

	FileOffset.QuadPart += sizeof(IMAGE_NT_HEADERS);
	pImageSectionHeader = (IMAGE_SECTION_HEADER*)ExAllocatePool(NonPagedPool, sizeof(IMAGE_SECTION_HEADER) * ImageNtHeader.FileHeader.NumberOfSections);
	status = ZwReadFile(hFile, NULL, NULL, NULL, &IoStatusBlock, pImageSectionHeader, \
		sizeof(IMAGE_SECTION_HEADER) * ImageNtHeader.FileHeader.NumberOfSections, &FileOffset, 0);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("读取sectionHeader<失败>.\n");
		DbgPrint("%x", status);
		ExFreePool(pImageSectionHeader);
		ZwClose(hFile);
		return;
	}
	//拉伸PE
	pVirtualPointer = ExAllocatePool(NonPagedPool, ImageNtHeader.OptionalHeader.SizeOfImage);
	RtlZeroMemory(pVirtualPointer, ImageNtHeader.OptionalHeader.SizeOfImage);
	/*
	RtlCopyMemory(pVirtualPointer, &ImageDosHeader, sizeof(IMAGE_DOS_HEADER));
	RtlCopyMemory((PVOID)((UCHAR)pVirtualPointer + ImageDosHeader.e_lfanew), &ImageNtHeader, sizeof(IMAGE_NT_HEADERS));
	RtlCopyMemory((PVOID)((ULONG)pVirtualPointer + ImageDosHeader.e_lfanew + sizeof(IMAGE_NT_HEADERS)), pImageSectionHeader, \
		sizeof(IMAGE_SECTION_HEADER) * ImageNtHeader.FileHeader.NumberOfSections);
	//可能复制不完全,应该直接复制SizeOfHeaders
	*/
	FileOffset.QuadPart = 0;
	status = ZwReadFile(hFile, NULL, NULL, NULL, &IoStatusBlock, pVirtualPointer, ImageNtHeader.OptionalHeader.SizeOfHeaders, &FileOffset, 0);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("Headers数据读取<失败>.\n");
		DbgPrint("%x", status);
		ExFreePool(pImageSectionHeader);
		ExFreePool(pVirtualPointer);
		ZwClose(hFile);
		return;
	}
	
	for (uLoop = 0; uLoop < ImageNtHeader.FileHeader.NumberOfSections; uLoop++)
	{
		SectionVirtualAddress = pImageSectionHeader[uLoop].VirtualAddress;//对应区段相对偏移
		if (pImageSectionHeader[uLoop].Misc.VirtualSize > pImageSectionHeader[uLoop].SizeOfRawData)
		{
			SectionSize = pImageSectionHeader[uLoop].Misc.VirtualSize;//取最大的占用空间
		}
		else
		{
			SectionSize = pImageSectionHeader[uLoop].SizeOfRawData;
		}		
		FileOffset.QuadPart = pImageSectionHeader[uLoop].PointerToRawData;//对应区段的超始地址
		status = ZwReadFile(hFile, NULL, NULL, NULL, &IoStatusBlock, (PVOID)((ULONG)pVirtualPointer + SectionVirtualAddress), SectionSize, &FileOffset, 0);
		if (!NT_SUCCESS(status))
		{
			DbgPrint("uLoop:%x.\n", uLoop);
			DbgPrint("节表数据读取<失败>.\n");
			DbgPrint("%x", status);
			ExFreePool(pImageSectionHeader);
			ExFreePool(pVirtualPointer);
			ZwClose(hFile);
			return;
		}
	}
	//拉伸完成
	ExFreePool(pImageSectionHeader);
	DbgPrint("pVirtualPointer: %x\n", pVirtualPointer);
	FixBaseRelocationTable(pVirtualPointer);
	MakeNewSSDT(pVirtualPointer);
	//DbgBreakPoint();
	//ExFreePool(pVirtualPointer);
	pVirtualPointerTmp = pVirtualPointer;
	ZwClose(hFile);
}

void FixBaseRelocationTable(PVOID pNewImage)
{
	//2.根据重定位表修复全局变量
	PIMAGE_DOS_HEADER pImageDosHeader;
	PIMAGE_NT_HEADERS pImageNtHeader;
	ULONG OldImageBase;
	IMAGE_DATA_DIRECTORY ImageDataDirectory;
	PIMAGE_BASE_RELOCATION pImageBaseRelocation;
	ULONG uRelocTableSize;
	USHORT* pTypeOffset;
	ULONG uIndex;
	ULONG Type;
	ULONG* uRelocAddress;

	//定位header
	pImageDosHeader = (PIMAGE_DOS_HEADER)pNewImage;
	pImageNtHeader = (PIMAGE_NT_HEADERS)((ULONG)pNewImage + pImageDosHeader->e_lfanew);
	OldImageBase = pImageNtHeader->OptionalHeader.ImageBase;
	//定位重定位表
	ImageDataDirectory = pImageNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
	if (ImageDataDirectory.VirtualAddress == NULL)
	{
		DbgPrint("没有找到重定位表.\n");
		return;
	}
	pImageBaseRelocation = (PIMAGE_BASE_RELOCATION)((ULONG)pNewImage + ImageDataDirectory.VirtualAddress);
	//开始修复重定位表
	while ((pImageBaseRelocation->VirtualAddress != 0) && (pImageBaseRelocation->SizeOfBlock != 0))
	{
		pTypeOffset = (USHORT*)(pImageBaseRelocation + 8);
		uRelocTableSize = (pImageBaseRelocation->SizeOfBlock - 8) / 2;
		for (uIndex = 0; uIndex < uRelocTableSize; uIndex++)
		{
			Type = pTypeOffset[uIndex] >> 12;
			if (Type == 3)
			{
				uRelocAddress = (ULONG*)((ULONG)(pTypeOffset[uIndex] & 0x0fff) + pImageBaseRelocation->VirtualAddress + (ULONG)pNewImage);
				*uRelocAddress = *uRelocAddress + (OrigImage - OldImageBase);	//这里和普通exe修复地址不一样,需要用到现在内核的地址,得遍历链表才行,现在先写死.
			}

		}
		pImageBaseRelocation = (IMAGE_BASE_RELOCATION*)((ULONG)pImageBaseRelocation + pImageBaseRelocation->SizeOfBlock);
	}
}

void MakeNewSSDT(PVOID pNewImage)
{
	//SSTD表就在内核里面
	ULONG uNewKernelInc;
	ULONG uOffset;
	ULONG uIndex;
	//新内核地址-老内核地址，得到相对偏移
	uNewKernelInc = (ULONG)pNewImage - OrigImage;
	//老内核的ssdt指针加上相对偏移，得到新内核的ssdt指针
	pNewSSDT = (KSYSTEM_SERVICE_TABLE*)((ULONG)&KeServiceDescriptorTable + uNewKernelInc);

	if (!MmIsAddressValid(pNewSSDT))
	{
		DbgPrint("找不到NewSSTD");
		return;
	}
	//数量相同
	pNewSSDT->NumberOfService = KeServiceDescriptorTable.NumberOfService;
	//计算相对函数地址
	uOffset = (ULONG)KeServiceDescriptorTable.ServiceTableBase - OrigImage;
	//得到新的ssdt函数表地址
	pNewSSDT->ServiceTableBase = (ULONG*)((ULONG)pNewImage + uOffset);
	if (!MmIsAddressValid(pNewSSDT->ServiceTableBase))
	{
		DbgPrint("pNewSSDT->ServiceTableBase: %x", pNewSSDT->ServiceTableBase);
		return;
	}
	//依次遍历
	for (uIndex = 0; uIndex < pNewSSDT->NumberOfService; uIndex++)
	{//新的函数地址再加上相对加载地址，得到现在的ssdt函数地址
		pNewSSDT->ServiceTableBase[uIndex] += uNewKernelInc;
	}
}



void UnloadDriver(PDRIVER_OBJECT driver) {

	ExFreePool(pVirtualPointerTmp);
	DbgPrint("驱动停止了.\n");
}
```

 HOOK KiFastCallEntry

![image-20230410205954224](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230410205954224.png)

```c
/*
重载内核
1.申请内存,按内存对齐展开
2.根据重定位表修复全局变量
3.修复IAT表(修复导入表的说法不准确)
4.山寨系统服务表
5.狸猫换太子(Hook KiFastCallEntry)
*/
#include <ntifs.h>
#include <ntimage.h>
/*
typedef struct _KSYSTEM_SERVICE_TABLE
{
	PULONG ServiceTableBase;			// 函数地址表
	PULONG ServiceCounterTableBase;		// SSDT 函数被调用的次数
	ULONG NumberOfService;				// 函数个数
	PULONG ParamTableBase;				// 函数参数表
} KSYSTEM_SERVICE_TABLE, * PKSYSTEM_SERVICE_TABLE;
*/
typedef struct _KSYSTEM_SERVICE_TABLE
{
	PULONG ServiceTableBase;
	PULONG ServiceCounterTableBase;
	ULONG NumberOfServices;
	PULONG ParamTableBase;
}KSYSTEM_SERVICE_TABLE, * PKSYSTEM_SERVICE_TABLE;
//__declspec(dllimport) KSYSTEM_SERVICE_TABLE KeServiceDescriptorTable;
extern "C" PKSYSTEM_SERVICE_TABLE KeServiceDescriptorTable;

ULONG OrigImage = 0x804D8000;
KSYSTEM_SERVICE_TABLE* pNewSSDT;
PVOID pVirtualPointerTmp;
ULONG JmpRet;

void LoadKernel();
void FixBaseRelocationTable(PVOID pNewImage);
void MakeNewSSDT(PVOID pNewImage);
void PageProtectOn();
void PageProtectOff();
void HookKiFastCallEntry();
void MyKiFastCallEntry();
ULONG DisPlay(ULONG ServiceTableBase, ULONG FuncIndex, ULONG OrigFuncAddress);
void UnloadDriver(PDRIVER_OBJECT driver);

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
	DbgPrint("驱动已加载.\n");
	DbgPrint("开始重载内核.\n");

	LoadKernel();
	HookKiFastCallEntry();
	DriverObject->DriverUnload = UnloadDriver;    //为驱动指定卸载函数
	return STATUS_SUCCESS;
}

void LoadKernel()
{
	//1.申请内存, 按内存对齐展开
	NTSTATUS status;
	UNICODE_STRING KernelPath;
	HANDLE hFile;
	OBJECT_ATTRIBUTES ObjAttr;
	IO_STATUS_BLOCK IoStatusBlock;
	LARGE_INTEGER FileOffset;
	IMAGE_DOS_HEADER ImageDosHeader;
	IMAGE_NT_HEADERS32 ImageNtHeader;
	PIMAGE_SECTION_HEADER pImageSectionHeader;
	PVOID pVirtualPointer;
	ULONG uLoop;
	ULONG SectionVirtualAddress;
	ULONG SectionSize;

	InitializeObjectAttributes(&ObjAttr, &KernelPath, OBJ_CASE_INSENSITIVE, NULL, NULL);

	RtlInitUnicodeString(&KernelPath, L"\\??\\C:\\WINDOWS\\system32\\ntkrnlpa.exe");
	status = ZwCreateFile(&hFile, FILE_ALL_ACCESS, &ObjAttr, &IoStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN, FILE_NON_DIRECTORY_FILE, NULL, 0);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("打开内核文件<失败>.\n");
		DbgPrint("%x", status);
		ZwClose(hFile);
		return;
	}
	DbgPrint("打开内核文件<成功>.\n");

	FileOffset.QuadPart = 0;	//文件偏移量位0,dos.
	status = ZwReadFile(hFile, NULL, NULL, NULL, &IoStatusBlock, &ImageDosHeader, sizeof(IMAGE_DOS_HEADER), &FileOffset, 0);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("读取dosHeader<失败>.\n");
		DbgPrint("%x", status);
		ZwClose(hFile);
		return;
	}

	FileOffset.QuadPart += ImageDosHeader.e_lfanew;
	status = ZwReadFile(hFile, NULL, NULL, NULL, &IoStatusBlock, &ImageNtHeader, sizeof(IMAGE_NT_HEADERS32), &FileOffset, 0);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("读取ntHeader<失败>.\n");
		DbgPrint("%x", status);
		ZwClose(hFile);
		return;
	}

	FileOffset.QuadPart += sizeof(IMAGE_NT_HEADERS);
	pImageSectionHeader = (IMAGE_SECTION_HEADER*)ExAllocatePool(NonPagedPool, sizeof(IMAGE_SECTION_HEADER) * ImageNtHeader.FileHeader.NumberOfSections);
	status = ZwReadFile(hFile, NULL, NULL, NULL, &IoStatusBlock, pImageSectionHeader, \
		sizeof(IMAGE_SECTION_HEADER) * ImageNtHeader.FileHeader.NumberOfSections, &FileOffset, 0);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("读取sectionHeader<失败>.\n");
		DbgPrint("%x", status);
		ExFreePool(pImageSectionHeader);
		ZwClose(hFile);
		return;
	}
	//拉伸PE
	pVirtualPointer = ExAllocatePool(NonPagedPool, ImageNtHeader.OptionalHeader.SizeOfImage);
	RtlZeroMemory(pVirtualPointer, ImageNtHeader.OptionalHeader.SizeOfImage);
	/*
	RtlCopyMemory(pVirtualPointer, &ImageDosHeader, sizeof(IMAGE_DOS_HEADER));
	RtlCopyMemory((PVOID)((UCHAR)pVirtualPointer + ImageDosHeader.e_lfanew), &ImageNtHeader, sizeof(IMAGE_NT_HEADERS));
	RtlCopyMemory((PVOID)((ULONG)pVirtualPointer + ImageDosHeader.e_lfanew + sizeof(IMAGE_NT_HEADERS)), pImageSectionHeader, \
		sizeof(IMAGE_SECTION_HEADER) * ImageNtHeader.FileHeader.NumberOfSections);
	//可能复制不完全,应该直接复制SizeOfHeaders
	*/
	FileOffset.QuadPart = 0;
	status = ZwReadFile(hFile, NULL, NULL, NULL, &IoStatusBlock, pVirtualPointer, ImageNtHeader.OptionalHeader.SizeOfHeaders, &FileOffset, 0);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("Headers数据读取<失败>.\n");
		DbgPrint("%x", status);
		ExFreePool(pImageSectionHeader);
		ExFreePool(pVirtualPointer);
		ZwClose(hFile);
		return;
	}

	for (uLoop = 0; uLoop < ImageNtHeader.FileHeader.NumberOfSections; uLoop++)
	{
		SectionVirtualAddress = pImageSectionHeader[uLoop].VirtualAddress;//对应区段相对偏移
		if (pImageSectionHeader[uLoop].Misc.VirtualSize > pImageSectionHeader[uLoop].SizeOfRawData)
		{
			SectionSize = pImageSectionHeader[uLoop].Misc.VirtualSize;//取最大的占用空间
		}
		else
		{
			SectionSize = pImageSectionHeader[uLoop].SizeOfRawData;
		}
		FileOffset.QuadPart = pImageSectionHeader[uLoop].PointerToRawData;//对应区段的超始地址
		status = ZwReadFile(hFile, NULL, NULL, NULL, &IoStatusBlock, (PVOID)((ULONG)pVirtualPointer + SectionVirtualAddress), SectionSize, &FileOffset, 0);
		if (!NT_SUCCESS(status))
		{
			DbgPrint("uLoop:%x.\n", uLoop);
			DbgPrint("节表数据读取<失败>.\n");
			DbgPrint("%x", status);
			ExFreePool(pImageSectionHeader);
			ExFreePool(pVirtualPointer);
			ZwClose(hFile);
			return;
		}
	}
	//拉伸完成
	ExFreePool(pImageSectionHeader);
	DbgPrint("pVirtualPointer: %x\n", pVirtualPointer);
	FixBaseRelocationTable(pVirtualPointer);
	MakeNewSSDT(pVirtualPointer);
	//DbgBreakPoint();
	//ExFreePool(pVirtualPointer);
	pVirtualPointerTmp = pVirtualPointer;
	ZwClose(hFile);
}

void FixBaseRelocationTable(PVOID pNewImage)
{
	//2.根据重定位表修复全局变量
	PIMAGE_DOS_HEADER pImageDosHeader;
	PIMAGE_NT_HEADERS pImageNtHeader;
	ULONG OldImageBase;
	IMAGE_DATA_DIRECTORY ImageDataDirectory;
	PIMAGE_BASE_RELOCATION pImageBaseRelocation;
	ULONG uRelocTableSize;
	USHORT* pTypeOffset;
	ULONG uIndex;
	ULONG Type;
	ULONG* uRelocAddress;

	//定位header
	pImageDosHeader = (PIMAGE_DOS_HEADER)pNewImage;
	pImageNtHeader = (PIMAGE_NT_HEADERS)((ULONG)pNewImage + pImageDosHeader->e_lfanew);
	OldImageBase = pImageNtHeader->OptionalHeader.ImageBase;
	//定位重定位表
	ImageDataDirectory = pImageNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
	if (ImageDataDirectory.VirtualAddress == NULL)
	{
		DbgPrint("没有找到重定位表.\n");
		return;
	}
	pImageBaseRelocation = (PIMAGE_BASE_RELOCATION)((ULONG)pNewImage + ImageDataDirectory.VirtualAddress);
	//开始修复重定位表
	while ((pImageBaseRelocation->VirtualAddress != 0) && (pImageBaseRelocation->SizeOfBlock != 0))
	{
		pTypeOffset = (USHORT*)(pImageBaseRelocation + 8);
		uRelocTableSize = (pImageBaseRelocation->SizeOfBlock - 8) / 2;
		for (uIndex = 0; uIndex < uRelocTableSize; uIndex++)
		{
			Type = pTypeOffset[uIndex] >> 12;
			if (Type == 3)
			{
				uRelocAddress = (ULONG*)((ULONG)(pTypeOffset[uIndex] & 0x0fff) + pImageBaseRelocation->VirtualAddress + (ULONG)pNewImage);
				*uRelocAddress = *uRelocAddress + (OrigImage - OldImageBase);	//这里和普通exe修复地址不一样,需要用到现在内核的地址,得遍历链表才行,现在先写死.
			}

		}
		pImageBaseRelocation = (IMAGE_BASE_RELOCATION*)((ULONG)pImageBaseRelocation + pImageBaseRelocation->SizeOfBlock);
	}
}

VOID MakeNewSSDT(PVOID pNewImage)
{
    //新内核地址-老内核地址，得到相对偏移
    ULONG uNewKernelInc = (ULONG)pNewImage - OrigImage;
 
    //老内核的ssdt指针加上相对偏移，得到新内核的ssdt指针
    pNewSSDT = (PKSYSTEM_SERVICE_TABLE)((ULONG)KeServiceDescriptorTable + uNewKernelInc);
 
    if (!MmIsAddressValid(pNewSSDT))
    {
        DbgPrint("pNewSSDT is unaviable!\r\n");
        return;
    }
 
    //由于数量是一个数值，因此不必作相对偏移
    pNewSSDT->NumberOfServices = KeServiceDescriptorTable->NumberOfServices;
 
    //计算相对函数地址
    ULONG uOffset = (ULONG)KeServiceDescriptorTable->ServiceTableBase - OrigImage;
 
    //得到新的ssdt函数表地址
    pNewSSDT->ServiceTableBase = (PULONG)((ULONG)pNewImage + uOffset);
 
    if (!MmIsAddressValid(pNewSSDT->ServiceTableBase))
    {
        DbgPrint("pNewSSDT->ServiceTableBase: %X\r\n", pNewSSDT->ServiceTableBase);
        return;
    }
 
    //依次遍历
    for (ULONG uIndex = 0; uIndex<pNewSSDT->NumberOfServices; uIndex++)
    {//新的函数地址再加上相对加载地址，得到现在的ssdt函数地址
        pNewSSDT->ServiceTableBase[uIndex] += uNewKernelInc;
    }
}

void PageProtectOn()
{
	__asm {//恢复内存保护  
		mov  eax, cr0
		or eax, 10000h
		mov  cr0, eax
		sti
	}
}
void PageProtectOff()
{
	__asm {//去掉内存保护
		cli
		mov  eax, cr0
		and eax, not 10000h
		mov  cr0, eax
	}
}

void HookKiFastCallEntry()
{
	ULONG KiFastCallEntryAdder;
	ULONG KiFastCallEntryHookAdder;
	UCHAR jmpbuffer[5] = { 0 };
	ULONG i;
	_asm
	{
		pushad
		mov ecx, 0x176;
		rdmsr
			mov KiFastCallEntryAdder, eax
			popad
	}
	DbgPrint("KiFastCallEntryAdder:%x\n", KiFastCallEntryAdder);
	for (i = 0; i < 1000; i++)
	{
		if (*(UCHAR*)(KiFastCallEntryAdder + i + 0) == 0x2B &&
			*(UCHAR*)(KiFastCallEntryAdder + i + 1) == 0xE1 &&
			*(UCHAR*)(KiFastCallEntryAdder + i + 2) == 0xC1 &&
			*(UCHAR*)(KiFastCallEntryAdder + i + 3) == 0xE9 &&
			*(UCHAR*)(KiFastCallEntryAdder + i + 4) == 0x02)
		{
			KiFastCallEntryHookAdder = KiFastCallEntryAdder + i;
			break;
		}
	}
	if (KiFastCallEntryHookAdder == NULL)
	{
		DbgPrint("KiFastCallEntryHookAdder没找到.\n");
	}
	JmpRet = KiFastCallEntryHookAdder + 5;
	jmpbuffer[0] = 0xE8;
	*(DWORD32*)&jmpbuffer[1] = (DWORD32)((DWORD32)MyKiFastCallEntry - KiFastCallEntryHookAdder - 5);
	PageProtectOff();
	RtlCopyMemory((PVOID)KiFastCallEntryHookAdder, jmpbuffer, 5);
	PageProtectOn();
}

__declspec(naked) void MyKiFastCallEntry()
{
	__asm
	{
		pushad
		pushfd
		push	ebx
		push	eax
		push	edi
		call	DisPlay
		//再返回前修改堆栈里的数据
		mov[esp + 0x14], eax
		popfd
		popad
		//恢复以前的代码，以便内核正常运行
		sub esp, ecx
		shr ecx, 2
		jmp JmpRet
	}
}

ULONG DisPlay(ULONG ServiceTableBase, ULONG FuncIndex, ULONG OrigFuncAddress)
{

	return OrigFuncAddress;
}


void UnloadDriver(PDRIVER_OBJECT driver) {

	ExFreePool(pVirtualPointerTmp);
	DbgPrint("驱动停止了.\n");
}
```

SSDT表有问题,明天再搞.

```c
/*
重载内核
1.申请内存,按内存对齐展开
2.根据重定位表修复全局变量
3.修复IAT表(修复导入表的说法不准确)
4.山寨系统服务表
5.狸猫换太子(Hook KiFastCallEntry)
*/
#include <ntifs.h>
#include <ntimage.h>

typedef struct _KSYSTEM_SERVICE_TABLE
{
	PULONG ServiceTableBase;			// 函数地址表
	PULONG ServiceCounterTableBase;		// SSDT 函数被调用的次数
	ULONG NumberOfService;				// 函数个数
	PULONG ParamTableBase;				// 函数参数表
} KSYSTEM_SERVICE_TABLE, * PKSYSTEM_SERVICE_TABLE;

__declspec(dllimport) KSYSTEM_SERVICE_TABLE KeServiceDescriptorTable;

ULONG OrigImage = 0x804D8000;
KSYSTEM_SERVICE_TABLE* pNewSSDT;
PVOID pVirtualPointerTmp;
ULONG JmpRet;

void LoadKernel();
void FixBaseRelocationTable(PVOID pNewImage);
void MakeNewSSDT(PVOID pNewImage);
void PageProtectOn();
void PageProtectOff();
void HookKiFastCallEntry();
void MyKiFastCallEntry();
ULONG DisPlay(ULONG ServiceTableBase, ULONG FuncIndex, ULONG OrigFuncAddress);
void UnloadDriver(PDRIVER_OBJECT driver);

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
	DbgPrint("驱动已加载.\n");
	DbgPrint("开始重载内核.\n");

	LoadKernel();
	HookKiFastCallEntry();
	DriverObject->DriverUnload = UnloadDriver;    //为驱动指定卸载函数
	return STATUS_SUCCESS;
}

void LoadKernel()
{
	//1.申请内存, 按内存对齐展开
	NTSTATUS status;
	UNICODE_STRING KernelPath;
	HANDLE hFile;
	OBJECT_ATTRIBUTES ObjAttr;
	IO_STATUS_BLOCK IoStatusBlock;
	LARGE_INTEGER FileOffset;
	IMAGE_DOS_HEADER ImageDosHeader;
	IMAGE_NT_HEADERS32 ImageNtHeader;
	PIMAGE_SECTION_HEADER pImageSectionHeader;
	PVOID pVirtualPointer;
	ULONG uLoop;
	ULONG SectionVirtualAddress;
	ULONG SectionSize;

	InitializeObjectAttributes(&ObjAttr, &KernelPath, OBJ_CASE_INSENSITIVE, NULL, NULL);

	RtlInitUnicodeString(&KernelPath, L"\\??\\C:\\WINDOWS\\system32\\ntkrnlpa.exe");
	status = ZwCreateFile(&hFile, FILE_ALL_ACCESS, &ObjAttr, &IoStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN, FILE_NON_DIRECTORY_FILE, NULL, 0);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("打开内核文件<失败>.\n");
		DbgPrint("%x", status);
		ZwClose(hFile);
		return;
	}
	DbgPrint("打开内核文件<成功>.\n");

	FileOffset.QuadPart = 0;	//文件偏移量位0,dos.
	status = ZwReadFile(hFile, NULL, NULL, NULL, &IoStatusBlock, &ImageDosHeader, sizeof(IMAGE_DOS_HEADER), &FileOffset, 0);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("读取dosHeader<失败>.\n");
		DbgPrint("%x", status);
		ZwClose(hFile);
		return;
	}

	FileOffset.QuadPart += ImageDosHeader.e_lfanew;
	status = ZwReadFile(hFile, NULL, NULL, NULL, &IoStatusBlock, &ImageNtHeader, sizeof(IMAGE_NT_HEADERS32), &FileOffset, 0);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("读取ntHeader<失败>.\n");
		DbgPrint("%x", status);
		ZwClose(hFile);
		return;
	}

	FileOffset.QuadPart += sizeof(IMAGE_NT_HEADERS);
	pImageSectionHeader = (IMAGE_SECTION_HEADER*)ExAllocatePool(NonPagedPool, sizeof(IMAGE_SECTION_HEADER) * ImageNtHeader.FileHeader.NumberOfSections);
	status = ZwReadFile(hFile, NULL, NULL, NULL, &IoStatusBlock, pImageSectionHeader, \
		sizeof(IMAGE_SECTION_HEADER) * ImageNtHeader.FileHeader.NumberOfSections, &FileOffset, 0);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("读取sectionHeader<失败>.\n");
		DbgPrint("%x", status);
		ExFreePool(pImageSectionHeader);
		ZwClose(hFile);
		return;
	}
	//拉伸PE
	pVirtualPointer = ExAllocatePool(NonPagedPool, ImageNtHeader.OptionalHeader.SizeOfImage);
	RtlZeroMemory(pVirtualPointer, ImageNtHeader.OptionalHeader.SizeOfImage);
	/*
	RtlCopyMemory(pVirtualPointer, &ImageDosHeader, sizeof(IMAGE_DOS_HEADER));
	RtlCopyMemory((PVOID)((UCHAR)pVirtualPointer + ImageDosHeader.e_lfanew), &ImageNtHeader, sizeof(IMAGE_NT_HEADERS));
	RtlCopyMemory((PVOID)((ULONG)pVirtualPointer + ImageDosHeader.e_lfanew + sizeof(IMAGE_NT_HEADERS)), pImageSectionHeader, \
		sizeof(IMAGE_SECTION_HEADER) * ImageNtHeader.FileHeader.NumberOfSections);
	//可能复制不完全,应该直接复制SizeOfHeaders
	*/
	FileOffset.QuadPart = 0;
	status = ZwReadFile(hFile, NULL, NULL, NULL, &IoStatusBlock, pVirtualPointer, ImageNtHeader.OptionalHeader.SizeOfHeaders, &FileOffset, 0);
	if (!NT_SUCCESS(status))
	{
		DbgPrint("Headers数据读取<失败>.\n");
		DbgPrint("%x", status);
		ExFreePool(pImageSectionHeader);
		ExFreePool(pVirtualPointer);
		ZwClose(hFile);
		return;
	}
	
	for (uLoop = 0; uLoop < ImageNtHeader.FileHeader.NumberOfSections; uLoop++)
	{
		SectionVirtualAddress = pImageSectionHeader[uLoop].VirtualAddress;//对应区段相对偏移
		if (pImageSectionHeader[uLoop].Misc.VirtualSize > pImageSectionHeader[uLoop].SizeOfRawData)
		{
			SectionSize = pImageSectionHeader[uLoop].Misc.VirtualSize;//取最大的占用空间
		}
		else
		{
			SectionSize = pImageSectionHeader[uLoop].SizeOfRawData;
		}		
		FileOffset.QuadPart = pImageSectionHeader[uLoop].PointerToRawData;//对应区段的超始地址
		status = ZwReadFile(hFile, NULL, NULL, NULL, &IoStatusBlock, (PVOID)((ULONG)pVirtualPointer + SectionVirtualAddress), SectionSize, &FileOffset, 0);
		if (!NT_SUCCESS(status))
		{
			DbgPrint("uLoop:%x.\n", uLoop);
			DbgPrint("节表数据读取<失败>.\n");
			DbgPrint("%x", status);
			ExFreePool(pImageSectionHeader);
			ExFreePool(pVirtualPointer);
			ZwClose(hFile);
			return;
		}
	}
	//拉伸完成
	ExFreePool(pImageSectionHeader);
	DbgPrint("pVirtualPointer: %x\n", pVirtualPointer);
	FixBaseRelocationTable(pVirtualPointer);
	MakeNewSSDT(pVirtualPointer);
	//DbgBreakPoint();
	//ExFreePool(pVirtualPointer);
	pVirtualPointerTmp = pVirtualPointer;
	ZwClose(hFile);
}

void FixBaseRelocationTable(PVOID pNewImage)
{
	//2.根据重定位表修复全局变量
	PIMAGE_DOS_HEADER pImageDosHeader;
	PIMAGE_NT_HEADERS pImageNtHeader;
	ULONG OldImageBase;
	IMAGE_DATA_DIRECTORY ImageDataDirectory;
	PIMAGE_BASE_RELOCATION pImageBaseRelocation;
	ULONG uRelocTableSize;
	USHORT* pTypeOffset;
	ULONG uIndex;
	ULONG Type;
	ULONG* uRelocAddress;

	//定位header
	pImageDosHeader = (PIMAGE_DOS_HEADER)pNewImage;
	pImageNtHeader = (PIMAGE_NT_HEADERS)((ULONG)pNewImage + pImageDosHeader->e_lfanew);
	OldImageBase = pImageNtHeader->OptionalHeader.ImageBase;
	//定位重定位表
	ImageDataDirectory = pImageNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
	if (ImageDataDirectory.VirtualAddress == NULL)
	{
		DbgPrint("没有找到重定位表.\n");
		return;
	}
	pImageBaseRelocation = (PIMAGE_BASE_RELOCATION)((ULONG)pNewImage + ImageDataDirectory.VirtualAddress);
	//开始修复重定位表
	while ((pImageBaseRelocation->VirtualAddress != 0) && (pImageBaseRelocation->SizeOfBlock != 0))
	{
		pTypeOffset = (USHORT*)(pImageBaseRelocation + 8);
		uRelocTableSize = (pImageBaseRelocation->SizeOfBlock - 8) / 2;
		for (uIndex = 0; uIndex < uRelocTableSize; uIndex++)
		{
			Type = pTypeOffset[uIndex] >> 12;
			if (Type == 3)
			{
				uRelocAddress = (ULONG*)((ULONG)(pTypeOffset[uIndex] & 0x0fff) + pImageBaseRelocation->VirtualAddress + (ULONG)pNewImage);
				*uRelocAddress = *uRelocAddress + (OrigImage - OldImageBase);	//这里和普通exe修复地址不一样,需要用到现在内核的地址,得遍历链表才行,现在先写死.
			}

		}
		pImageBaseRelocation = (IMAGE_BASE_RELOCATION*)((ULONG)pImageBaseRelocation + pImageBaseRelocation->SizeOfBlock);
	}
}

VOID MakeNewSSDT(PVOID pNewImage)
{
	ULONG uIndex;
	ULONG uNewKernelInc,uOffset;
	//新内核地址-老内核地址，得到相对偏移
	uNewKernelInc = (ULONG)pNewImage - OrigImage;
	//老内核的ssdt指针加上相对偏移，得到新内核的ssdt指针
	pNewSSDT = (PKSYSTEM_SERVICE_TABLE)((ULONG)&KeServiceDescriptorTable + uNewKernelInc);

	if (!MmIsAddressValid(pNewSSDT))
	{
		KdPrint(("pNewSSDT is unaviable!"));
		return;
	}
	//由于数量是一个数值，因此不必作相对偏移
	pNewSSDT->NumberOfService = KeServiceDescriptorTable.NumberOfService;
	//计算相对函数地址
	uOffset = (ULONG)KeServiceDescriptorTable.ServiceTableBase -OrigImage;
	//得到新的ssdt函数表地址
	pNewSSDT->ServiceTableBase = (ULONG*)((ULONG)pNewImage + uOffset);
	if (!MmIsAddressValid(pNewSSDT->ServiceTableBase))
	{
		KdPrint(("pNewSSDT->ServiceTableBase: %x",pNewSSDT->ServiceTableBase));
		return;
	}
	//依次遍历
	for (uIndex = 0;uIndex<pNewSSDT->NumberOfService;uIndex++)
	{//新的函数地址再加上相对加载地址，得到现在的ssdt函数地址
		pNewSSDT->ServiceTableBase[uIndex] += uNewKernelInc;
	}
	DbgPrint("pNewSSDT:%p\n", pNewSSDT);
	DbgBreakPoint();
}

void PageProtectOn()
{
	__asm {//恢复内存保护  
		mov  eax, cr0
		or eax, 10000h
		mov  cr0, eax
		sti
	}
}
void PageProtectOff()
{
	__asm {//去掉内存保护
		cli
		mov  eax, cr0
		and eax, not 10000h
		mov  cr0, eax
	}
}

void HookKiFastCallEntry()
{
	ULONG KiFastCallEntryAdder;
	ULONG KiFastCallEntryHookAdder;
	UCHAR jmpbuffer[5] = { 0 };
	ULONG i;
	_asm
	{
		pushad
		mov ecx, 0x176;
		rdmsr
		mov KiFastCallEntryAdder, eax
		popad
	}
	DbgPrint("KiFastCallEntryAdder:%x\n", KiFastCallEntryAdder);
	for (i = 0; i < 1000; i++)
	{
		if (*(UCHAR*)(KiFastCallEntryAdder + i + 0) == 0x2B &&
			*(UCHAR*)(KiFastCallEntryAdder + i + 1) == 0xE1 &&
			*(UCHAR*)(KiFastCallEntryAdder + i + 2) == 0xC1 &&
			*(UCHAR*)(KiFastCallEntryAdder + i + 3) == 0xE9 &&
			*(UCHAR*)(KiFastCallEntryAdder + i + 4) == 0x02)
		{
			KiFastCallEntryHookAdder = KiFastCallEntryAdder + i;
			break;
		}
	}
	if (KiFastCallEntryHookAdder == NULL)
	{
		DbgPrint("KiFastCallEntryHookAdder没找到.\n");
	}
	JmpRet = KiFastCallEntryHookAdder + 5;
	jmpbuffer[0] = 0xE8;
	*(DWORD32*)&jmpbuffer[1] = (DWORD32)((DWORD32)MyKiFastCallEntry - KiFastCallEntryHookAdder - 5);
	PageProtectOff();
	RtlCopyMemory((PVOID)KiFastCallEntryHookAdder, jmpbuffer, 5);
	PageProtectOn();
}

__declspec(naked) void MyKiFastCallEntry()
{
	__asm
	{
		pushad
		pushfd
		push	ebx
		push	eax
		push	edi
		call	DisPlay
		//再返回前修改堆栈里的数据
		mov[esp + 0x14], eax
		popfd
		popad
		//恢复以前的代码，以便内核正常运行
		sub esp, ecx
		shr ecx, 2
		jmp JmpRet
	}
}

ULONG DisPlay(ULONG ServiceTableBase, ULONG FuncIndex, ULONG OrigFuncAddress)
{
	DbgPrint("ServiceTableBase:%x, FuncIndex:%x, OrigFuncAddress:%x.\n", ServiceTableBase, FuncIndex, OrigFuncAddress);
	return OrigFuncAddress;
}


void UnloadDriver(PDRIVER_OBJECT driver) {

	ExFreePool(pVirtualPointerTmp);
	DbgPrint("驱动停止了.\n");
}
```

![image-20230411114451729](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230411114451729.png)

需要切换到ntkrnlpa.exe(29912分页),SSDT能正常用,但是调用里面函数就崩,Hook KiFastCallEntry成功.

![image-20230411114638136](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230411114638136.png)

IAT表没修复?

## 3.系统调用

不说废话了,直接分析内核.

ReadProcessMemory

kernel32.dll

```assembly
mov     edi, edi
push    ebp
mov     ebp, esp
lea     eax, [ebp+nSize]
push    eax             ; NumberOfBytesRead
push    [ebp+nSize]     ; NumberOfBytesToRead
push    [ebp+lpBuffer]  ; Buffer
push    [ebp+lpBaseAddress] ; BaseAddress
push    [ebp+hProcess]  ; ProcessHandle
call    ds:__imp__NtReadVirtualMemory@20 ; NtReadVirtualMemory(x,x,x,x,x)	//调用了ntdll的NtReadVirtualMemory函数,跟过去.
```

ntdll.dll

```assembly
mov     eax, 0BAh       ; NtReadVirtualMemory	//系统服务号
mov     edx, 7FFE0300h
call    dword ptr [edx]	;ff call,这里涉及到了一个结构体.
retn    14h
```

_KUSER_SHARED_DATA

```
kd> dt _KUSER_SHARED_DATA
nt!_KUSER_SHARED_DATA
   +0x000 TickCountLow     : Uint4B
   +0x004 TickCountMultiplier : Uint4B
   +0x008 InterruptTime    : _KSYSTEM_TIME
   +0x014 SystemTime       : _KSYSTEM_TIME
   +0x020 TimeZoneBias     : _KSYSTEM_TIME
   +0x02c ImageNumberLow   : Uint2B
   +0x02e ImageNumberHigh  : Uint2B
   +0x030 NtSystemRoot     : [260] Uint2B
   +0x238 MaxStackTraceDepth : Uint4B
   +0x23c CryptoExponent   : Uint4B
   +0x240 TimeZoneId       : Uint4B
   +0x244 Reserved2        : [8] Uint4B
   +0x264 NtProductType    : _NT_PRODUCT_TYPE
   +0x268 ProductTypeIsValid : UChar
   +0x26c NtMajorVersion   : Uint4B
   +0x270 NtMinorVersion   : Uint4B
   +0x274 ProcessorFeatures : [64] UChar
   +0x2b4 Reserved1        : Uint4B
   +0x2b8 Reserved3        : Uint4B
   +0x2bc TimeSlip         : Uint4B
   +0x2c0 AlternativeArchitecture : _ALTERNATIVE_ARCHITECTURE_TYPE
   +0x2c8 SystemExpirationDate : _LARGE_INTEGER
   +0x2d0 SuiteMask        : Uint4B
   +0x2d4 KdDebuggerEnabled : UChar
   +0x2d5 NXSupportPolicy  : UChar
   +0x2d8 ActiveConsoleId  : Uint4B
   +0x2dc DismountCount    : Uint4B
   +0x2e0 ComPlusPackage   : Uint4B
   +0x2e4 LastSystemRITEventTickCount : Uint4B
   +0x2e8 NumberOfPhysicalPages : Uint4B
   +0x2ec SafeBootMode     : UChar
   +0x2f0 TraceLogging     : Uint4B
   +0x2f8 TestRetInstruction : Uint8B
   +0x300 SystemCall       : Uint4B	//就是ff call了这个地方
   +0x304 SystemCallReturn : Uint4B
   +0x308 SystemCallPad    : [3] Uint8B
   +0x320 TickCount        : _KSYSTEM_TIME
   +0x320 TickCountQuad    : Uint8B
   +0x330 Cookie           : Uint4B
```

SystemCall是一个指针,指向的地址的代码可能会不一样,具体是cpu是否支持快速调用决定的,操作系统在开机的时候会初始化这个地址的代码.

分为快速系统调用和中断门,本质都是提权,从ring3进ring0.提权的本质就是替换寄存器的值,这里根据替换的方式分为了上面2种.

```
kd> .process 89f2b420
ReadVirtual: 89f2b438 not properly sign extended
Implicit process is now 89f2b420
WARNING: .cache forcedecodeuser is not enabled
kd> dd 7FFE0300h
7ffe0300  7c92e4f0 7c92e4f4 00000000 00000000
7ffe0310  00000000 00000000 00000000 00000000
7ffe0320  00000000 00000000 00000000 00000000
7ffe0330  f7619a65 00000000 00000000 00000000
7ffe0340  00000000 00000000 00000000 00000000
7ffe0350  00000000 00000000 00000000 00000000
7ffe0360  00000000 00000000 00000000 00000000
7ffe0370  00000000 00000000 00000000 00000000
kd> u 7c92e4f0
7c92e4f0 8bd4            mov     edx,esp
7c92e4f2 0f34            sysenter
7c92e4f4 c3              ret
```

把esp放到了edx里面,然后执行了sysenter,快速系统调用提权.顾名思义,快速系统调用把要用到的cs ss eip esp的值存放到了msr这个寄存器里面,之前在获取KiFastCallEntry地址的时候用过.

```assembly
_asm
	{
		pushad
		mov ecx, 0x176;	//这里的176就是EIP0将要获取到的值,即KiFastCallEntry的入口点.
		rdmsr
		mov KiFastCallEntryAdder, eax
		popad
	}
```

| **MSR**           | **地址** |
| ----------------- | -------- |
| IA32_SYSENTER_CS  | 174H     |
| IA32_SYSENTER_ESP | 175H     |
| IA32_SYSENTER_EIP | 176H     |

```
kd> rdmsr 174
msr[174] = 00000000`00000008
kd> rdmsr 175
msr[175] = 00000000`ba4d0000
kd> rdmsr 176
msr[176] = 00000000`805426e0	//KiFastCallEntry的入口地址
kd> u KiFastCallEntry
nt!KiFastCallEntry:
805426e0 b923000000      mov     ecx,23h	//现在已经进ring0了
805426e5 6a30            push    30h
805426e7 0fa1            pop     fs
805426e9 8ed9            mov     ds,cx
805426eb 8ec1            mov     es,cx
805426ed 648b0d40000000  mov     ecx,dword ptr fs:[40h]
805426f4 8b6104          mov     esp,dword ptr [ecx+4]
805426f7 6a23            push    23h
```

OK,在ring3快速系统调用提权使用的函数是ntdll.dll!KiFastSystemCall(),中断门提权使用的函数是ntdll.dll!KiIntSystemCall().

ntdll.dll!KiFastSystemCall()

```assembly
mov     edx, esp
sysenter
```

ntdll.dll!KiIntSystemCall()

```assembly
lea     edx, [esp+arg_4]
int     2Eh             ; DOS 2+ internal - EXECUTE COMMAND
                        ; DS:SI -> counted CR-terminated command string
retn
```

我们先从最基础的中断门提权开始分析.

```assembly
arg_4= byte ptr  8

lea     edx, [esp+arg_4];这里edx获取了之前ReadProcessMemory传递的堆栈,eax里面保存了系统服务号.
int     2Eh             ; DOS 2+ internal - EXECUTE COMMAND
                        ; DS:SI -> counted CR-terminated command string
```

int 2e,OK,去看一下IDT表

```
kd> dq 8003f400+2e*8
ReadVirtual: 8003f570 not properly sign extended
8003f570  8054ee00`00082611 80548e00`0008590c
8003f580  80548e00`00081cd0 80548e00`00081cda
8003f590  80548e00`00081ce4 80548e00`00081cee
8003f5a0  80548e00`00081cf8 80548e00`00081d02
8003f5b0  80548e00`00081d0c 806e8e00`00087864
8003f5c0  80548e00`00081d20 80548e00`00081d2a
8003f5d0  80548e00`00081d34 80548e00`00081d3e
8003f5e0  80548e00`00081d48 806e8e00`00088e2c
```

拆分一下8054ee00`00082611,cs为0008,eip为80542611,ss和esp从tss获取,跟到80542611.

```
kd> u 80542611
ReadVirtual: 80542611 not properly sign extended
80542611 6a00            push    0
80542613 55              push    ebp
80542614 53              push    ebx
80542615 56              push    esi
80542616 57              push    edi
80542617 0fa0            push    fs
80542619 bb30000000      mov     ebx,30h
8054261e 668ee3          mov     fs,bx
kd> u KiSystemService
nt!KiSystemService:
80542611 6a00            push    0
80542613 55              push    ebp
80542614 53              push    ebx
80542615 56              push    esi
80542616 57              push    edi
80542617 0fa0            push    fs
80542619 bb30000000      mov     ebx,30h
8054261e 668ee3          mov     fs,bx
```

我的windbg有点问题,其实这个地址就是KiSystemService这个函数,现在已经进入到ring0了,所以现在应该用ida分析ntoskrnl.exe了

ntoskrnl.exe

KiSystemService()

```assembly
; int __usercall KiSystemService@<eax>(int@<edx>, int@<ebx>, int@<ebp>, int@<edi>, int@<esi>, char)
_KiSystemService proc near

arg_0= dword ptr  4

push    0	;//这里涉及到了_ktrap_Frame这个结构体.
push    ebp
push    ebx
push    esi
push    edi	
push    fs	;//保存一下寄存器的值
mov     ebx, 30h ; '0'
mov     fs, ebx	;//fs = 00110 0 00,段选择子为5,加载段选择子,指向_KPCR结构体
push    large dword ptr fs:0	;//_KPCR(+0x000 NtTib:_NT_TIB)->_NT_TIB(+0x000 ExceptionList:Ptr32 _EXCEPTION_REGISTRATION_RECORD),保存ExceptionList
mov     large dword ptr fs:0, 0FFFFFFFFh	;设置ExceptionList为-1
mov     esi, large fs:124h	;//esi指向_KPRCB.CurrentThread,当前CPU所执行线程的_ETHREAD
push    dword ptr [esi+140h]	;//+0x140 PreviousMode:Char,先前模式入栈,PreviousMode=0表示从0环调用过来,PreviousMode=1表示从3环调用过来
sub     esp, 48h	;//提升栈顶,现在esp指向_ktrap_Frame的第一个成员(+0x000 DbgEbp:Uint4B)
mov     ebx, [esp+68h+arg_0]	;//esp+68h+4,ebx=cs3
and     ebx, 1	;//001B&0001,判断之前的权限是0环还是3环,现在ebx=1
mov     [esi+140h], bl	;//设置PreviousMode为1
mov     ebp, esp	;//提升ebp,现在ebp指向_ktrap_Frame的第一个成员(+0x000 DbgEbp:Uint4B)
mov     ebx, [esi+134h]	;//(+0x134 TrapFrame : Ptr32 _KTRAP_FRAME)放入ebx
mov     [ebp+3Ch], ebx	;//(+0x03c Edx:Uint4B)=(+0x134 TrapFrame:Ptr32 _KTRAP_FRAME),暂时放一放
mov     [esi+134h], ebp	;//将_ktrap_Frame的地址放入_ETHREAD.TrapFrame,即当前线程的TrapFrame指向现在的TrapFrame.
cld	;//flag寄存器df位清零
mov     ebx, [ebp+60h]	;//将ebx=ebp3
mov     edi, [ebp+68h]	;//edi=eip3(返回地址)
mov     [ebp+0Ch], edx	;//_KTRAP_FRAME.DbgArgPointer = edx,之前的参数指针
mov     dword ptr [ebp+8], 0BADB0D00h	;//不用管
mov     [ebp+0], ebx	;//DbgEbp=ebp3
mov     [ebp+4], edi	;//DbgEip=eip3
test    byte ptr [esi+2Ch], 0FFh	;//_ETHREAD. _KTHREAD.DebugActive 判断是否处于调试模式
jnz     Dr_kss_a
loc_406841:
sti	;//允许中断
jmp     loc_406932
_KiSystemService endp
```

KiFastSystemCall()

```assembly
mov     ecx, 23h	;//00100 0 11,写入ds,es
push    30h
pop     fs	;//将fs设置为30和之前一样,fs = 00110 0 00,段选择子为5,加载段选择子,指向_KPCR结构体
mov     ds, ecx
mov     es, ecx
mov     ecx, large fs:40h	;//ecx=_KPCR.TSS
mov     esp, [ecx+4]	;//esp=_KTSS.Esp0
push    23h	;//ss3
push    edx	;//esp3
pushf	;//push eflag3
push    2
add     edx, 8	;//esp3+8,返回地址
popf	;//设置eflag0为2
or      [esp+0Ch+var_B], 2	;//或,
push    1Bh	;//cs3
push    dword ptr ds:0FFDF0304h	;//_KUSER_SHARED_DATA.SystemCallReturn,返回地址
push    0	;//errcode
push    ebp
push    ebx
push    esi
push    edi
mov     ebx, large fs:1Ch	;//_KPCR.SelfPcr,为_KPCR结构体自身地址,ebx=_KPCR
push    3Bh	;//fs3
mov     esi, [ebx+124h]	;//_KPCR._KPRCB.CurrentThread
push    dword ptr [ebx]	;//_KPCR._NT_TIB.ExceptionList
mov     dword ptr [ebx], 0FFFFFFFFh	;//设置为-1
mov     ebp, [esi+18h]	;//ebp=_ETHREAD._KTHREAD.InitialStack
push    1	;//_ktrap_Frame.PreviousPreviousMode,设置先前模式为1
sub     esp, 48h	;//提升栈顶,esp=_ktrap_Frame
sub     ebp, 29Ch	;//ebp=_ETHREAD._KTHREAD.InitialStack-0x29C
mov     byte ptr [esi+140h], 1	;//_ETHREAD._KTHREAD.PreviousMode=1
cmp     ebp, esp	;//比较ebp和esp.
jnz     loc_40686C
and     dword ptr [ebp+2Ch], 0	;//清空_ktrap_Frame.Dr7
test    byte ptr [esi+2Ch], 0FFh	;//_ETHREAD._KTHREAD.DebugActive是否为-1
mov     [esi+134h], ebp	;//_ETHREAD._KTHREAD.TrapFrame=ebp,当前线程的TrapFrame指向当前的TrapFrame
jnz     Dr_FastCallDrSave
loc_40691B:
mov     ebx, [ebp+60h]	;//ebx=ebp3
mov     edi, [ebp+68h]	;//edi=eip3(返回地址)
mov     [ebp+0Ch], edx	;//_ktrap_Frame.DbgArgPointer,写入之前的函数参数堆栈
mov     dword ptr [ebp+8], 0BADB0D00h	;//_ktrap_Frame.DbgArgMark=0BADB0D00h
mov     [ebp+0], ebx	;//DbgEbp=ebp3
mov     [ebp+4], edi	;//DbgEip=eip3(返回地址)
sti	;//设置允许中断
```

初始化工作完成,现在KiSystemService()和KiFastSystemCall()一样了

```assembly
loc_406932:
mov     edi, eax	;//edi=系统调用号
shr     edi, 8	;//系统调用号右移8位
and     edi, 30h	;//30,0011 0000,检测第12位是否为1,走ntoskrl.exe还是win32k.sys
mov     ecx, edi	;//ecx存储0x00或者0x10(调用号大于0x1000)
add     edi, [esi+0E0h]	;//_ETHREAD._KTHREAD.ServiceTable,edi现在存放着SSDT表的地址
mov     ebx, eax	;//ebx=系统调用号
and     eax, 0FFFh	;//系统调用号只要后12位
cmp     eax, [edi+8]	;//判断系统调用号是否在服务函数的个数里面
jnb     _KiBBTUnexpectedRange
cmp     ecx, 10h	;//与0x10比较,0x10(调用号大于0x1000)
jnz     short loc_406972
;如果调用号大于0x1000才执行下面的,先不看了
mov     ecx, large fs:18h
xor     ebx, ebx
...
loc_406972:
inc     large dword ptr fs:638h	;//_KPCR._KPRCB.KeSystemCalls+1
mov     esi, edx	;//esi=edx=函数参数指针
mov     ebx, [edi+0Ch]	;//edi=系统服务表,edi+0xch=参数个数表
xor     ecx, ecx	;//清零ecx
mov     cl, [eax+ebx]	;//cl=[参数个数表+系统调用号]=需要的参数总长度
mov     edi, [edi]	;//edi=系统服务表的函数地址表
mov     ebx, [edi+eax*4]	;//ebx=要调用的函数的地址
sub     esp, ecx	;//提升堆栈,提升高度为需要的参数总长度
shr     ecx, 2	;//参数总长度/4==参数的个数
mov     edi, esp	;//edi=函数参数堆栈地址
test    byte ptr [ebp+72h], 2	;//对比之前设置的eflag0是否还是为2,校验一下之前有没有跳转什么的.和海哥的内核有差异,但是问题不大.
jnz     short loc_40699B
test    byte ptr [ebp+6Ch], 1	;//判断cs3是否是3环的
jz      short _KiSystemServiceCopyArguments@0 ; KiSystemServiceCopyArguments()
;如果是3环就执行下面的
cmp     esi, ds:_MmUserProbeAddress	;//检查3环的参数地址范围有没有越界.即ring3,0x7FFFFFFF.
jnb     loc_406B4F
...
rep		movsd	;//开始复制参数了,(esi=函数参数指针)(edi=函数参数堆栈地址),将数据从ESI指向的内存位置复制到EDI指向的内存位置,复制ecx次.
call 	ebx	;//call	ebx=要调用的函数的地址
```

_ktrap_Frame

```
kd> dt _ktrap_Frame
nt!_KTRAP_FRAME
   +0x000 DbgEbp           : Uint4B
   +0x004 DbgEip           : Uint4B
   +0x008 DbgArgMark       : Uint4B
   +0x00c DbgArgPointer    : Uint4B
   +0x010 TempSegCs        : Uint4B
   +0x014 TempEsp          : Uint4B
   +0x018 Dr0              : Uint4B
   +0x01c Dr1              : Uint4B
   +0x020 Dr2              : Uint4B
   +0x024 Dr3              : Uint4B
   +0x028 Dr6              : Uint4B
   +0x02c Dr7              : Uint4B
   +0x030 SegGs            : Uint4B
   +0x034 SegEs            : Uint4B
   +0x038 SegDs            : Uint4B
   +0x03c Edx              : Uint4B
   +0x040 Ecx              : Uint4B
   +0x044 Eax              : Uint4B
   +0x048 PreviousPreviousMode : Uint4B	//push PreviousMode
   +0x04c ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD	//push ExceptionList
   +0x050 SegFs            : Uint4B	//push fs 保存一下寄存器的值
   +0x054 Edi              : Uint4B	//push edi
   +0x058 Esi              : Uint4B	//push esi
   +0x05c Ebx              : Uint4B	//push ebx
   +0x060 Ebp              : Uint4B	//push ebp
   +0x064 ErrCode          : Uint4B	//push 0,填充一下errcode
   +0x068 Eip              : Uint4B	//中断门提权压栈的几个寄存器
   +0x06c SegCs            : Uint4B
   +0x070 EFlags           : Uint4B
   +0x074 HardwareEsp      : Uint4B
   +0x078 HardwareSegSs    : Uint4B
   +0x07c V86Es            : Uint4B	//虚拟8086模式,现在不用
   +0x080 V86Ds            : Uint4B
   +0x084 V86Fs            : Uint4B
   +0x088 V86Gs            : Uint4B
```

```
mov     ebx, 30h ; '0'
mov     fs, ebx	//fs = 00110 0 00,段选择子为6,看一下这个表
```

![image-20230412155421485](./%E6%BB%B4%E6%B0%B4%E4%B8%89%E6%9C%9F%E4%B8%AD%E7%BA%A7%E7%AC%94%E8%AE%B0.assets/image-20230412155421485.png)

0xFFDFF000 Data RW Ac,指向_KPCR结构体.

_KPCR

```
kd> dt _KPCR 0xFFDFF000
nt!_KPCR
   +0x000 NtTib            : _NT_TIB	//又指向_NT_TIB结构体
   +0x01c SelfPcr          : 0xffdff000 _KPCR
   +0x020 Prcb             : 0xffdff120 _KPRCB
   +0x024 Irql             : 0 ''
   +0x028 IRR              : 0
   +0x02c IrrActive        : 0
   +0x030 IDR              : 0xffffffff
   +0x034 KdVersionBlock   : 0x8054e2b8 Void
   +0x038 IDT              : 0x8003f400 _KIDTENTRY
   +0x03c GDT              : 0x8003f000 _KGDTENTRY
   +0x040 TSS              : 0x80042000 _KTSS
   +0x044 MajorVersion     : 1
   +0x046 MinorVersion     : 1
   +0x048 SetMember        : 1
   +0x04c StallScaleFactor : 0x840
   +0x050 DebugActive      : 0 ''
   +0x051 Number           : 0 ''
   +0x052 Spare0           : 0 ''
   +0x053 SecondLevelCacheAssociativity : 0 ''
   +0x054 VdmAlert         : 0
   +0x058 KernelReserved   : [14] 0
   +0x090 SecondLevelCacheSize : 0
   +0x094 HalReserved      : [16] 0
   +0x0d4 InterruptMode    : 0
   +0x0d8 Spare1           : 0 ''
   +0x0dc KernelReserved2  : [17] 0
   +0x120 PrcbData         : _KPRCB
```

_NT_TIB

```
kd> dt _NT_TIB 0xFFDFF000
nt!_NT_TIB
   +0x000 ExceptionList    : 0x80551cb0 _EXCEPTION_REGISTRATION_RECORD
   +0x004 StackBase        : 0x805524f0 Void
   +0x008 StackLimit       : 0x8054f700 Void
   +0x00c SubSystemTib     : (null) 
   +0x010 FiberData        : (null) 
   +0x010 Version          : 0
   +0x014 ArbitraryUserPointer : (null) 
   +0x018 Self             : (null) 
```

_KPRCB

```
kd> dt _KPRCB 0xFFDFF120
nt!_KPRCB
   +0x000 MinorVersion     : 1
   +0x002 MajorVersion     : 1
   +0x004 CurrentThread    : 0x8055ce60 _KTHREAD
   +0x008 NextThread       : (null) 
   +0x00c IdleThread       : 0x8055ce60 _KTHREAD
   +0x010 Number           : 0 ''
   +0x011 Reserved         : 0 ''
   +0x012 BuildType        : 0
   +0x014 SetMember        : 1
   +0x018 CpuType          : 6 ''
   +0x019 CpuID            : 1 ''
   +0x01a CpuStep          : 0x9702
   +0x01c ProcessorState   : _KPROCESSOR_STATE
   +0x33c KernelReserved   : [16] 0
   +0x37c HalReserved      : [16] 0
   +0x3bc PrcbPad0         : [92]  ""
   +0x418 LockQueue        : [16] _KSPIN_LOCK_QUEUE
   +0x498 PrcbPad1         : [8]  ""
   +0x4a0 NpxThread        : (null) 
   +0x4a4 InterruptCount   : 0x1a56e
   +0x4a8 KernelTime       : 0xda40
   +0x4ac UserTime         : 0xe35
   +0x4b0 DpcTime          : 1
   +0x4b4 DebugDpcTime     : 0
   +0x4b8 InterruptTime    : 0x269
   +0x4bc AdjustDpcThreshold : 0x14
   +0x4c0 PageColor        : 0x7af7a
   +0x4c4 SkipTick         : 0
   +0x4c8 MultiThreadSetBusy : 0 ''
   +0x4c9 Spare2           : [3]  ""
   +0x4cc ParentNode       : 0x8055d560 _KNODE
   +0x4d0 MultiThreadProcessorSet : 1
   +0x4d4 MultiThreadSetMaster : 0xffdff120 _KPRCB
   +0x4d8 ThreadStartCount : [2] 0
   +0x4e0 CcFastReadNoWait : 0
   +0x4e4 CcFastReadWait   : 0xb5eb
   +0x4e8 CcFastReadNotPossible : 0
   +0x4ec CcCopyReadNoWait : 0x42
   +0x4f0 CcCopyReadWait   : 0xdc75
   +0x4f4 CcCopyReadNoWaitMiss : 0xe
   +0x4f8 KeAlignmentFixupCount : 0
   +0x4fc KeContextSwitches : 0x9e875
   +0x500 KeDcacheFlushCount : 0
   +0x504 KeExceptionDispatchCount : 0x2ffe
   +0x508 KeFirstLevelTbFills : 0
   +0x50c KeFloatingEmulationCount : 0
   +0x510 KeIcacheFlushCount : 0
   +0x514 KeSecondLevelTbFills : 0
   +0x518 KeSystemCalls    : 0x78893e
   +0x51c SpareCounter0    : [1] 0
   +0x520 PPLookasideList  : [16] _PP_LOOKASIDE_LIST
   +0x5a0 PPNPagedLookasideList : [32] _PP_LOOKASIDE_LIST
   +0x6a0 PPPagedLookasideList : [32] _PP_LOOKASIDE_LIST
   +0x7a0 PacketBarrier    : 0
   +0x7a4 ReverseStall     : 2
   +0x7a8 IpiFrame         : (null) 
   +0x7ac PrcbPad2         : [52]  ""
   +0x7e0 CurrentPacket    : [3] (null) 
   +0x7ec TargetSet        : 0
   +0x7f0 WorkerRoutine    : (null) 
   +0x7f4 IpiFrozen        : 0
   +0x7f8 PrcbPad3         : [40]  ""
   +0x820 RequestSummary   : 0
   +0x824 SignalDone       : (null) 
   +0x828 PrcbPad4         : [56]  ""
   +0x860 DpcListHead      : _LIST_ENTRY [ 0x8055d4c4 - 0x8055d4c4 ]
   +0x868 DpcStack         : 0xba4d0000 Void
   +0x86c DpcCount         : 0x8757
   +0x870 DpcQueueDepth    : 1
   +0x874 DpcRoutineActive : 0
   +0x878 DpcInterruptRequested : 0
   +0x87c DpcLastCount     : 0x8757
   +0x880 DpcRequestRate   : 0
   +0x884 MaximumDpcQueueDepth : 1
   +0x888 MinimumDpcRate   : 3
   +0x88c QuantumEnd       : 0
   +0x890 PrcbPad5         : [16]  ""
   +0x8a0 DpcLock          : 0
   +0x8a4 PrcbPad6         : [28]  ""
   +0x8c0 CallDpc          : _KDPC
   +0x8e0 ChainedInterruptList : (null) 
   +0x8e4 LookasideIrpFloat : 0n1487
   +0x8e8 SpareFields0     : [6] 0
   +0x900 VendorString     : [13]  "GenuineIntel"
   +0x90d InitialApicId    : 0 ''
   +0x90e LogicalProcessorsPerPhysicalProcessor : 0x1 ''
   +0x910 MHz              : 0x840
   +0x914 FeatureBits      : 0xa0013fff
   +0x918 UpdateSignature  : _LARGE_INTEGER 0x0000001e`00000000
   +0x920 NpxSaveArea      : _FX_SAVE_AREA
   +0xb30 PowerState       : _PROCESSOR_POWER_STATE
```

## 4.进程与线程

ring0查看自身eprocess

```c
#include <ntifs.h>

void UnloadDriver(PDRIVER_OBJECT driver);

NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path)
{
	PEPROCESS pEprocess = NULL;
	PCHAR ImageFileName;
	ULONG pid;
	__asm
	{
		mov eax, fs: [0x124] ;	//fs指向_KPCR,_KPCR[0x124]=_KTHREAD
		mov eax, [eax + 0x220];	//_KTHREAD=_ETHREAD,_ETHREAD[0x220]=_EPROCESS
		mov pEprocess, eax;
		mov eax, [eax + 0x84];	//_EPROCESS[0x84]=UniqueProcessId(pid),_EPROCESS[0x174]=ImageFileName.
		mov pid, eax;
	}
	ImageFileName = (PCHAR)pEprocess + 0x174;
	DbgPrint("pid: %x, ImageFileName:%s\n", pid, ImageFileName);
	driver->DriverUnload = UnloadDriver;
	return STATUS_SUCCESS;
}

void UnloadDriver(PDRIVER_OBJECT driver)
{
	DbgPrint("驱动停止了。\r\n");
}
```

 模拟Windows线程调度

ts.h

```c
#pragma once
// ThreadCore.h: interface for the ThreadCore class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_THREADCORE_H__3C5DBE32_012F_4176_884F_8D9EA510122D__INCLUDED_)
#define AFX_THREADCORE_H__3C5DBE32_012F_4176_884F_8D9EA510122D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define NULL 0

#define MAXGMTHREAD	0x100


#define GMTHREAD_CREATE		0x01
#define GMTHREAD_READAY		0x02
#define GMTHREAD_RUNING		0x04
#define GMTHREAD_SLEEP		0x08
#define GMTHREAD_EXIT		0x100


//线程结构体(仿THREAD)
typedef struct
{
	char* name;						//线程名 相当于线程TID
	int Flags;						//线程状态
	int SleepMillisecondDot;		//休眠时间

	void* InitialStack;				//线程堆栈起始位置
	void* StackLimit;				//线程堆栈界限
	void* KernelStack;				//线程堆栈当前位置,也就是ESP

	void* lpParameter;				//线程函数的参数
	void (*func)(void* lpParameter);//线程函数

} GMThread_t;


//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------

extern GMThread_t GMThreadList[MAXGMTHREAD];//线程结构体数组

//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------


void IdleGMThread(void* lpParameter);

void initGMThread(GMThread_t* GMThreadp, char* name, void (*func)(void* lpParameter), void* lpParameter);
int RegisterGMThread(char* name, void (*func)(void* lpParameter), void* lpParameter);
void Scheduling(void);

void GMSleep(int Milliseconds);

void Thread1(void* lpParameter);
void Thread2(void* lpParameter);
void Thread3(void* lpParameter);
void Thread4(void* lpParameter);


#endif // !defined(AFX_THREADCORE_H__3C5DBE32_012F_4176_884F_8D9EA510122D__INCLUDED_)

```

main.c

```c
#include <Windows.h>
#include "ts.h"

extern int CurrentThreadindex;
int main(int argc, char* argv[])
{
	//初始化线程环境
	RegisterGMThread("Thread1", Thread1, NULL);
	RegisterGMThread("Thread2", Thread2, NULL);
	RegisterGMThread("Thread3", Thread3, NULL);
	RegisterGMThread("Thread4", Thread4, NULL);

	//仿Windows线程切换
	for (;;)
	{
		Sleep(20);	//假时钟,海哥讲错了,因为只能等Scheduling return回来才能再次Scheduling.
		Scheduling();
	}

	return 0;
}
//这个代码有2个问题:
//1.假时钟
//2.因为是假时钟所以,进程只能主动切换,即调用GMSleep的时候,所以进程在执行GMSleep之前并不会发生切换.
```

ts.c

```c
#include "stdio.h"
#include <windows.h>

#include "ts.h"

#define _SELF		"滴水_仿Windows线程切换"

//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------

int CurrentThreadindex = 0;
GMThread_t GMThreadList[MAXGMTHREAD] = { NULL,0 };

#define GMTHREADSTACKSIZE 0x80000

void* WindowsStackLimit = NULL;

//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------

__declspec(naked) void SwitchContext(GMThread_t* SrcGMThreadp, GMThread_t* DstGMThreadp)
{
	__asm
	{
		push ebp
		mov ebp, esp
		//sub esp,__LOCAL_SIZE
		push edi
		push esi
		push ebx
		push ecx
		push edx
		push eax

		mov esi, SrcGMThreadp
		mov edi, DstGMThreadp

		mov[esi + GMThread_t.KernelStack], esp
		//---------------经典堆栈切换 另一个线程复活----------------------------------
		mov esp, [edi + GMThread_t.KernelStack]


		pop eax
		pop edx
		pop ecx
		pop ebx
		pop esi
		pop edi
		//add esp,__LOCAL_SIZE
		pop ebp
		ret
	}
}


void GMThreadStartup(GMThread_t* GMThreadp)
{
	GMThreadp->func(GMThreadp->lpParameter);
	GMThreadp->Flags = GMTHREAD_EXIT;
	Scheduling();

	return;
}

void IdleGMThread(void* lpParameter)
{
	printf("IdleGMThread---------------\n");
	Scheduling();
	return;
}

void PushStack(unsigned int** Stackpp, unsigned int v)
{
	*Stackpp -= 1;
	**Stackpp = v;

	return;
}

void initGMThread(GMThread_t* GMThreadp, char* name, void (*func)(void* lpParameter), void* lpParameter)
{
	unsigned char* StackPages;
	unsigned int* StackDWORDParam;
	//结构初始化赋值
	GMThreadp->Flags = GMTHREAD_CREATE;

	GMThreadp->name = name;
	GMThreadp->func = func;
	GMThreadp->lpParameter = lpParameter;
	//申请空间
	StackPages = (unsigned char*)VirtualAlloc(NULL, GMTHREADSTACKSIZE, MEM_COMMIT, PAGE_READWRITE);
	//清零
	memset(StackPages, 0, GMTHREADSTACKSIZE);
	//堆栈初始化地址
	GMThreadp->InitialStack = (StackPages + GMTHREADSTACKSIZE);
	//堆栈限制
	GMThreadp->StackLimit = StackPages;
	//堆栈地址
	StackDWORDParam = (unsigned int*)GMThreadp->InitialStack;

	//入栈
	PushStack(&StackDWORDParam, (unsigned int)GMThreadp);		//通过这个指针来找到：线程函数、函数参数
	PushStack(&StackDWORDParam, (unsigned int)9);				//平衡堆栈
	PushStack(&StackDWORDParam, (unsigned int)GMThreadStartup);	//线程入口函数 这个函数负责调用线程函数
	PushStack(&StackDWORDParam, 5);								//push ebp
	PushStack(&StackDWORDParam, 7);								//push edi
	PushStack(&StackDWORDParam, 6);								//push esi
	PushStack(&StackDWORDParam, 3);								//push ebx
	PushStack(&StackDWORDParam, 2);								//push ecx
	PushStack(&StackDWORDParam, 1);								//push edx
	PushStack(&StackDWORDParam, 0);								//push eax

	GMThreadp->KernelStack = StackDWORDParam;


	GMThreadp->Flags = GMTHREAD_READAY;

	return;
}

int RegisterGMThread(char* name, void (*func)(void* lpParameter), void* lpParameter)
{
	int i;

	for (i = 1; GMThreadList[i].name; i++)
	{
		if (0 == stricmp(GMThreadList[i].name, name))
		{
			break;
		}
	}
	initGMThread(&GMThreadList[i], name, func, lpParameter);

	return (i | 0x55AA0000);
}

void Scheduling(void)
{
	int i;
	int TickCount;
	GMThread_t* SrcGMThreadp;
	GMThread_t* DstGMThreadp;

	TickCount = GetTickCount();

	SrcGMThreadp = &GMThreadList[CurrentThreadindex];

	DstGMThreadp = &GMThreadList[0];
	for (i = 1; GMThreadList[i].name; i++)
	{
		if (GMThreadList[i].Flags & GMTHREAD_SLEEP)
		{
			if (TickCount > GMThreadList[i].SleepMillisecondDot)
			{
				GMThreadList[i].Flags = GMTHREAD_READAY;
			}
		}

		if ((GMThreadList[i].Flags & GMTHREAD_READAY))
		{
			DstGMThreadp = &GMThreadList[i];
			break;
		}
	}

	CurrentThreadindex = DstGMThreadp - GMThreadList;
	SwitchContext(SrcGMThreadp, DstGMThreadp);

	return;
}

//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------

void GMSleep(int Milliseconds)
{
	GMThread_t* GMThreadp;
	GMThreadp = &GMThreadList[CurrentThreadindex];

	if ((GMThreadp->Flags) != 0)
	{
		GMThreadp->SleepMillisecondDot = GetTickCount() + Milliseconds;
		GMThreadp->Flags = GMTHREAD_SLEEP;
	}

	Scheduling();
	return;
}

//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------
void vmmprint(char* f, int l, char* fmt, ...)
{
	int ret;
	char buffer[0x100];
	va_list args;

	//----------------------------------
	va_start(args, fmt);
	_snprintf(buffer, 0x80, "[%s]:", f, l);
	ret = _vsnprintf(buffer + strlen(buffer), 0x100 - strlen(buffer), fmt, args);
	if (ret == -1)
	{
		strcpy(buffer, "vmmprint: error.");
	}
	//----------------------------------
	printf("%s", buffer);
	//OutputDebugString(buffer);

	return;
}

void Thread1(void* lpParameter)
{
	int i;
	for (i = 0; i < 3; i++)
	{
		vmmprint(_SELF, __LINE__, "Thread1 \n");
		while (1)
		{
			Sleep(1000);
			printf("Thread1");	//论证假时钟,如果main的时钟存在,这里肯定不会一直输出Thread1
		}
		
		GMSleep(1000);
	}

	return;
}

void Thread2(void* lpParameter)
{
	for (;;)
	{
		vmmprint(_SELF, __LINE__, "Thread2 \n");
		GMSleep(500);
	}

	return;
}

void Thread3(void* lpParameter)
{
	for (;;)
	{
		vmmprint(_SELF, __LINE__, "Thread3 \n");
		GMSleep(800);
	}

	return;
}

void Thread4(void* lpParameter)
{

	for (;;)
	{
		vmmprint(_SELF, __LINE__, "Thread4 \n");
		GMSleep(200);
	}

	return;
}

```

逆向KiSwapContext

```assembly
sub     esp, 10h	;//手动提升堆栈,和push一样
mov     [esp+10h+var_4], ebx	;//KPCR
mov     [esp+10h+var_8], esi	;//新线程 _ETHREAD
mov     [esp+10h+var_C], edi	;//旧线程 _ETHREAD
mov     [esp+10h+var_10], ebp	;//ebp没用?
mov     ebx, large fs:1Ch	;//ring0时fs指向_KPCR,_KPCR.SelfPcr
mov     esi, ecx	;//esi=ecx=新线程的_ETHREAD
mov     edi, [ebx+124h]	;//edi=_KPCR._KPRCB.CurrentThread
mov     [ebx+124h], esi	;//更新KPCR的CurrentThread
mov     cl, [edi+58h]	;//edi+58h=_ETHREAD._KTHREAD.WaitIrql
call    SwapContext	;//4个参数,ebx:KPCR,esi:新线程_ETHREAD,edi:旧线程_ETHREAD,cl:旧线程的WaitIrql,这个参数用来控制是否执行APC
mov     ebp, [esp+10h+var_10]	;//已经完成了线程切换,堆栈也切换了,恢复之前的寄存器
mov     edi, [esp+10h+var_C]
mov     esi, [esp+10h+var_8]
mov     ebx, [esp+10h+var_4]
add     esp, 10h
retn
```

逆向SwapContext

```assembly
.text:0046A8E0 ; 参数有4个，均通过寄存器保存
.text:0046A8E0 ; ebx: _KPCR
.text:0046A8E0 ; esi: 新线程 _ETHREAD
.text:0046A8E0 ; edi: 旧线程 _ETHREAD
.text:0046A8E0 ; cl: 旧线程的 WaitIrql，貌似用不到，直接覆盖了
.text:0046A8E0
.text:0046A8E0 SwapContext     proc near               ; CODE XREF: KiUnlockDispatcherDatabase(x)+72↑p
.text:0046A8E0                                         ; KiSwapContext(x)+29↑p ...
.text:0046A8E0                 or      cl, cl	;影响eflag的z标志位
.text:0046A8E2                 mov     es:[esi+_ETHREAD.Tcb.State], 2 ; 修改新线程状态为 2
.text:0046A8E2                                         ; 1 就绪
.text:0046A8E2                                         ; 2 运行
.text:0046A8E2                                         ; 5 等待
.text:0046A8E7                 pushf	;保存eflag寄存器
.text:0046A8E8
.text:0046A8E8 loc_46A8E8:                             ; CODE XREF: KiIdleLoop()+5A↓j
.text:0046A8E8                 mov     ecx, [ebx+_KPCR.NtTib.ExceptionList] ;
.text:0046A8E8                                         ; 保存本线程切换时的内核seh链表
.text:0046A8EA                 cmp     [ebx+_KPCR.PrcbData.DpcRoutineActive], 0 ; 是否有DPC，有就蓝屏
.text:0046A8F1                 push    ecx	;保存异常链表
.text:0046A8F2                 jnz     loc_46AA2D
.text:0046A8F8                 cmp     ds:_PPerfGlobalGroupMask, 0
.text:0046A8FF                 jnz     loc_46AA04
.text:0046A905
.text:0046A905 loc_46A905:                             ; CODE XREF: SwapContext+12C↓j
.text:0046A905                                         ; SwapContext+13D↓j ...
.text:0046A905                 mov     ebp, cr0        ; cr0 控制寄存器可以判断当前环境是实模式还是保护模式，是否开启分页模式，写保护
.text:0046A908                 mov     edx, ebp        ; edx = ebp = cr0
.text:0046A90A                 mov     cl, [esi+_ETHREAD.Tcb.DebugActive]	;debug
.text:0046A90D                 mov     [ebx+_KPCR.DebugActive], cl ; 更新 _KPCR 中当前线程的调试状态位，此时存的是新线程的值
.text:0046A910                 cli                     ; 屏蔽时钟中断
.text:0046A911                 mov     [edi+_ETHREAD.Tcb.KernelStack], esp	;!!!,保存旧线程的esp
.text:0046A914                 mov     eax, [esi+_ETHREAD.Tcb.InitialStack]
.text:0046A917                 mov     ecx, [esi+_ETHREAD.Tcb.StackLimit]
.text:0046A91A                 sub     eax, 210h       ; 线程堆栈的前 0x210 字节是浮点寄存器
.text:0046A91A                                         ; 此时 eax 指向 _KTRAP_FRAME.V86Gs
.text:0046A91F                 mov     [ebx+_KPCR.NtTib.StackLimit], ecx
.text:0046A922                 mov     [ebx+_KPCR.NtTib.StackBase], eax	;从新线程的_ETHREAD填充_KPCR
.text:0046A925                 xor     ecx, ecx	;清零ecx
.text:0046A927                 mov     cl, [esi+_ETHREAD.Tcb.NpxState]
.text:0046A92A                 and     edx, 0FFFFFFF1h ; 判断 NpxState 是否支持浮点
.text:0046A92A                                         ;
.text:0046A92A                                         ; 根据判断结果决定是否更新 cr0
.text:0046A92D                 or      ecx, edx
.text:0046A92F                 or      ecx, [eax+20Ch]
.text:0046A935                 cmp     ebp, ecx
.text:0046A937                 jnz     loc_46A9FC
.text:0046A93D                 lea     ecx, [ecx+0]
.text:0046A940
.text:0046A940 loc_46A940:                             ; CODE XREF: SwapContext+11F↓j
.text:0046A940                 test    dword ptr [eax-1Ch], 20000h ; SegCs & 20000h
.text:0046A940                                         ; 判断是否是虚拟8086模式，如果不是，直接减掉
.text:0046A940                                         ;    +0x07c V86Es            : Uint4B
.text:0046A940                                         ;    +0x080 V86Ds            : Uint4B
.text:0046A940                                         ;    +0x084 V86Fs            : Uint4B
.text:0046A940                                         ;    +0x088 V86Gs            : Uint4B
.text:0046A940                                         ;
.text:0046A940                                         ; 如果是，那么就不减
.text:0046A940                                         ;
.text:0046A940                                         ; 这样做了之后，eax 就指向了0环栈顶，接下来就会存储到 TSS 里
.text:0046A940                                         ; 以后这个线程进0环，不论是中断门还是快速调用，都会从 TSS 里获取 ESP0
.text:0046A947                 jnz     short loc_46A94C
.text:0046A949                 sub     eax, 10h
.text:0046A94C
.text:0046A94C loc_46A94C:                             ; CODE XREF: SwapContext+67↑j
.text:0046A94C                 mov     ecx, [ebx+_KPCR.TSS] ;
.text:0046A94C                                         ; ecx 指向 TSS
.text:0046A94C                                         ; TSS 的用途是3环进0环时，要从 TSS 取 SS0 和 ESP0
.text:0046A94F                 mov     [ecx+TSS.ESP0], eax ; 更新 TSS 中存储的0环栈顶 ESP0
.text:0046A952                 mov     esp, [esi+_ETHREAD.Tcb.KernelStack] ; 此处是切换线程，切换线程本质是切换堆栈
.text:0046A952                                         ; 将 esp 修改为新线程的栈顶，然后就可以从堆栈里取数据恢复现场了
.text:0046A955                 mov     eax, [esi+_ETHREAD.Tcb.Teb]
.text:0046A958                 mov     [ebx+_KPCR.NtTib.Self], eax ; 暂时存储 TEB 到 ffdff000
.text:0046A95B                 sti
.text:0046A95C                 mov     eax, [edi+_ETHREAD.Tcb.ApcState.Process]
.text:0046A95F                 cmp     eax, [esi+_ETHREAD.Tcb.ApcState.Process]
.text:0046A962                 mov     [edi+_ETHREAD.Tcb.IdleSwapBlock], 0
.text:0046A966                 jz      short loc_46A994 ; 如果是同一个进程内的线程切换，就跳转
.text:0046A966                                         ;
.text:0046A966                                         ; 如果不是同一个进程的，那么就要做额外的工作，主要就是切换CR3
.text:0046A968                 mov     edi, [esi+_ETHREAD.Tcb.ApcState.Process] ; edi: 新线程所属进程
.text:0046A96B                 test    [edi+_EPROCESS.Pcb.LdtDescriptor.LimitLow], 0FFFFh ; 判断 LDT
.text:0046A971                 jnz     short loc_46A9CE
.text:0046A973                 xor     eax, eax
.text:0046A975
.text:0046A975 loc_46A975:                             ; CODE XREF: SwapContext+117↓j
.text:0046A975                 lldt    ax              ; 修改 LDT 寄存器
.text:0046A978                 xor     eax, eax
.text:0046A97A                 mov     gs, eax         ; gs 寄存器清零
.text:0046A97A                                         ; 这就是 Windows 不使用 gs 的依据
.text:0046A97C                 assume gs:GAP
.text:0046A97C                 mov     eax, [edi+_EPROCESS.Pcb.DirectoryTableBase]
.text:0046A97F                 mov     ebp, [ebx+_KPCR.TSS]
.text:0046A982                 mov     ecx, dword ptr [edi+_EPROCESS.Pcb.IopmOffset]
.text:0046A985                 mov     [ebp+TSS.CR3], eax	;cr3寄存器也在tss里面
.text:0046A988                 mov     cr3, eax        ; 关键步骤：切换 cr3
.text:0046A98B                 mov     [ebp+TSS.IOMap], cx
.text:0046A98F                 jmp     short loc_46A994
.text:0046A98F ; ---------------------------------------------------------------------------
.text:0046A991                 align 4
.text:0046A994
.text:0046A994 loc_46A994:                             ; CODE XREF: SwapContext+86↑j
.text:0046A994                                         ; SwapContext+AF↑j
.text:0046A994                 mov     eax, [ebx+_KPCR.NtTib.Self] ;
.text:0046A994                                         ; 此时 eax 指向了 TEB
.text:0046A997                 mov     ecx, [ebx+_KPCR.GDT] ; 假设 GDT表在 0x8003f000
.text:0046A997                                         ; ecx = 0x8003f000
.text:0046A997                                         ; 3环 FS = 0x3B
.text:0046A997                                         ; 所以 FS 在 GDT表里的地址是 0x8003f03B,????怎么就0x8003f03B了?,3b(00111 0 11)索引为7,7*8=0x38,应该是0x8003f000+0x38=0x8003f038才对啊...
.text:0046A997                                         ; 下面的操作是修改 FS 的段描述符，这样3环 FS 就能找到 TEB 了
.text:0046A997                                         ; ;
.text:0046A99A                 mov     [ecx+3Ah], ax   ; BaseAddress 15:00,3a(00111 0 10)
.text:0046A99E                 shr     eax, 10h        ; eax 指向 TEB 的地址高16位
.text:0046A9A1                 mov     [ecx+3Ch], al   ; BaseAddress 23:16
.text:0046A9A4                 mov     [ecx+3Fh], ah   ; BaseAddress 31:24
.text:0046A9A7                 inc     [esi+_ETHREAD.Tcb.ContextSwitches]
.text:0046A9AA                 inc     [ebx+_KPCR.PrcbData.KeContextSwitches]
.text:0046A9B0                 pop     ecx
.text:0046A9B1                 mov     [ebx], ecx
.text:0046A9B3                 cmp     [esi+_ETHREAD.Tcb.ApcState.KernelApcPending], 0
.text:0046A9B7                 jnz     short loc_46A9BD
.text:0046A9B9                 popf
.text:0046A9BA                 xor     eax, eax
.text:0046A9BC                 retn
```

